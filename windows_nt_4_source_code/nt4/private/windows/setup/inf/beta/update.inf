;
; KEYED SECTIONS.  These sections are provided for files where a selection
; is made from a set of files and the chosen one is copied under a generic
; name.  This can be used to update the hal.dll, ntoskrnl.exe, ntbootdd.sys,
; ntdetect.com.
;


[FileKeyedClasses]
    Hal            = hal.dll
    Ntoskrnl       = ntoskrnl.exe
    ; Ntdetect       = ntdetect.com

[FilesKeyedSections]
    FilesHal       = $(STF_HALDEST)
    FilesNtoskrnl  = $(STF_WINDOWSSYSPATH)
    ; FilesNtdetect  = $(STF_OSLDEST)

[FilesHal]

    ; for x86

    ; hal      = 1, hal.dll      , RENAME=$(NEWFILE)
    ; halast   = 1, halast.dll   , RENAME=$(NEWFILE)
    ; halcbus  = 1, halcbus.dll  , RENAME=$(NEWFILE)
    ; hal486c  = 1, hal486c.dll  , RENAME=$(NEWFILE)
    ; halmca   = 1, halmca.dll   , RENAME=$(NEWFILE)
    ; halncr   = 1, halncr.dll   , RENAME=$(NEWFILE)
    ; haloli   = 1, haloli.dll   , RENAME=$(NEWFILE)
    ; halsp    = 1, halsp.dll    , RENAME=$(NEWFILE)
    ; halwyse7 = 1, halwyse7.dll , RENAME=$(NEWFILE)

    ; for mips

    ; hal      = 1, hal.dll      , RENAME=$(NEWFILE)
    ; haldti   = 1, haldti.dll   , RENAME=$(NEWFILE)
    ; halduomp = 1, halduomp.dll , RENAME=$(NEWFILE)
    ; halfxs   = 1, halfxs.dll   , RENAME=$(NEWFILE)
    ; halacr   = 1, halacr.dll   , RENAME=$(NEWFILE)
    ; halsgi   = 1, halsgi.dll   , RENAME=$(NEWFILE)

    ; for ppc

    ; hal            = 1, hal.dll         , RENAME=$(NEWFILE)
    ; halppc      = 1, halppc.dll    , RENAME=$(NEWFILE)
    ; halpolo     = 1, halpolo.dll    , RENAME=$(NEWFILE)
    ; halwood    = 1, halwood.dll  , RENAME=$(NEWFILE)

    ; for alpha

[FilesNtoskrnl]

    ; for ppc, x86, mips, alpha

    ; ntoskrnl = 1, ntoskrnl.exe , RENAME=$(NEWFILE)
    ; ntkrnlmp = 1, ntkrnlmp.exe , RENAME=$(NEWFILE)

; [FilesNtdetect]

    ; for x86

    ; ntdetect = 1, ntdetect.com , RENAME=$(NEWFILE)

;
; REGULAR SECTIONS.  These sections are provided for files where the file
; just needs to be copied to a known destination.
;

[FileSections]
    FilesPrimary        = C:
    FilesPal            = $(STF_HALDEST)
    FilesWinnt          = $(STF_WINDOWSPATH)
    FilesSystem32       = $(STF_WINDOWSSYSPATH)
    FilesSystem         = $(STF_WINDOWSPATH)\system
    FilesDrivers        = $(STF_WINDOWSSYSPATH)\drivers
    FilesConfig         = $(STF_WINDOWSSYSPATH)\config
    FilesWinspool       = $(STF_WINDOWSSYSPATH)\spool
    FilesPrnDriver      = $(STF_WINDOWSSYSPATH)\spool\drivers\$(!STF_PRNPLATFORM)\2
    FilesPrnProc        = $(STF_WINDOWSSYSPATH)\spool\prtprocs\$(!STF_PRNPLATFORM)
    FilesDbgCom         = $(STF_WINDOWSPATH)\symbols\com
    FilesDbgCpl         = $(STF_WINDOWSPATH)\symbols\cpl
    FilesDbgDll         = $(STF_WINDOWSPATH)\symbols\dll
    FilesDbgDrv         = $(STF_WINDOWSPATH)\symbols\drv
    FilesDbgExe         = $(STF_WINDOWSPATH)\symbols\exe
    FilesDbgScr         = $(STF_WINDOWSPATH)\symbols\scr
    FilesDbgSys         = $(STF_WINDOWSPATH)\symbols\sys

[FileSectionsOsLoader]
    FilesOsLoader       = $(STF_OSLDEST)

[FileSectionsFPNW]
    FilesFpNwLogin      = $(STF_FPNWSYSPATH)\login
    FilesFpNwPublic     = $(STF_FPNWSYSPATH)\public

[FileSectionsIIS]
    FilesIIS            = $(STF_IISPATH)

[FileSectionsIISAdmin]
    FilesIISAdmin       = $(STF_IISPATH)\iisadmin

[FileSectionsSSL]
    FilesSSL		= $(STF_WINDOWSSYSPATH)

[FileSectionsIE]
    FilesIE             = $(STF_IEPATH)

[FileSectionsHtr]
    FilesHtr            = $(STF_HTRPATH)\iisadmin

[FileSectionsCopyAlways]
    FilesSystem32CopyAlways = $(STF_WINDOWSSYSPATH)
    FilesDriversCopyAlways  = $(STF_WINDOWSSYSPATH)\drivers

;
; product specific sections
;

[FileSectionsWINNT]
    FilesInfWinnt       = $(STF_WINDOWSSYSPATH)

[FileSectionsLANMANNT]
    FilesInfLanmanNT    = $(STF_WINDOWSSYSPATH)

[FileSectionsCopyAlwaysWINNT]
    FilesSystem32CopyAlwaysWinnt = $(STF_WINDOWSSYSPATH)

[FileSectionsCopyAlwaysLANMANNT]
    FilesSystem32CopyAlwaysLanmanNT = $(STF_WINDOWSSYSPATH)

;
; FilesPrimary only covers ntldr.  For ntbootddd, a keyed section needs to
; be created.  Also this section is relevant only for x86.
;
[FilesPrimary]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

;
; FilesOsLoader only covers osloader.exe.  This is only relevant
;
[FilesOsLoader]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesPal]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesWinnt]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesSystem32]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesSystem]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDrivers]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesConfig]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesWinspool]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesPrnDriver]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesPrnProc]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDbgCom]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDbgCpl]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDbgDll]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDbgDrv]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDbgExe]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDbgScr]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDbgSys]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesInfWinnt]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesInfLanmanNT]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesSystem32CopyAlways]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDriversCopyAlways]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesSystem32CopyAlwaysWINNT]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesSystem32CopyAlwaysLANMANNT]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesFpNwLogin]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesFpNwPublic]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesIIS]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesIISAdmin]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesSSL]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesIE]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesHtr]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FileAttributes]
;1=1, NTLDR, $(FilesPrimary), SHR
;2=1, BOOT.INI, $(FilesPrimary), SHR


[ProcessorID]
    ProcessorID_I386  = I386
    ProcessorID_I486  = I486
    ProcessorID_I586  = I586
    ProcessorID_R4000 = R4000

[UiVars]
    STF_PLATFORMDET    = "" ? $(!LIBHANDLE) GetPlatform
    STF_CSDVER         = 512
    STF_BUILDVER       = 1381
    STF_CSD1_NT35      = 256
    STF_NT31_BUILDVER  = 528
    STF_NT35_BUILDVER  = 807
    STF_NT351_BUILDVER = 1057
    STF_NT40_BUILDVER  = 1381
    STF_NT40_MAJORVER  = 4
    STF_NT40_MINORVER  = 0
    STF_PRIMARY        = "C:"
    STF_NTDRIVE        = ""
    STF_WINDOWSPATH    = "" ? $(!LIBHANDLE) GetWindowsNtDir
    STF_WINDOWSSYSPATH = "" ? $(!LIBHANDLE) GetWindowsNtSysDir
    STF_CONTROLSET     = CurrentControlSet
    VolumeList         = {} ? $(!LIBHANDLE) GetHardDriveLetters
    VolumeFSList       = {} ? $(!LIBHANDLE) GetHardDriveFileSystems
    VolumeFreeList     = {} ? $(!LIBHANDLE) GetHardDriveFreeSpace
    DisketteList       = {} ? $(!LIBHANDLE) GetFloppyDriveLetters

    ;
    ; Amount of free space (in MB) required on the winnt drive
    ; before we'll do the upgrade patch.
    ;
[FreeSpaceI386]
    RequiredFreeWinnt  = 30
[FreeSpaceMips]
    RequiredFreeWinnt  = 30
[FreeSpaceppc]
    RequiredFreeWinnt  = 30
[FreeSpaceAlpha]
    RequiredFreeWinnt  = 30


[NVRAMVars]
    SystemPartition = "" ? $(!LIBHANDLE) GetNVRAMVar SYSTEMPARTITION
    OsLoader        = "" ? $(!LIBHANDLE) GetNVRAMVar OSLOADER
    OsLoadPartition = "" ? $(!LIBHANDLE) GetNVRAMVar OSLOADPARTITION
    OsLoadFilename  = "" ? $(!LIBHANDLE) GetNVRAMVar OSLOADFILENAME

;
; INF LOGIC
;

[Shell Commands]

    set-title "Windows NT Setup"
    set-subst CR = "\r"
    set-subst LF = "\n"
    set STF_LANGUAGE = ENG
    set STF_LANGUAGE_TYPE = 9
    read-syms Strings
    shell "subroutn.inf" PushBillboard STATUSDLG $(Billboard1)
    set BillboardPushed = TRUE
    set IISPathFound = FALSE
    set CopySSL = TRUE
    set CopyLoader = TRUE
    set FPNWSysPathFound = FALSE
    set IEPathFound = FALSE
    set HtrPathFound = FALSE

    set !LIBHANDLE      = ""
    set !PATCHLIBHANDLE = ""

    ;
    ; Initialize Library support for the inf
    ;

    install   LoadSetupLibrary

    ;
    ; find out the essential information about the installed hardware and
    ; software
    ;

    read-syms ProductType
    ifstr(i) $(!STF_PLATFORM) == I386
	set STF_PRNPLATFORM = "w32x86"
    else-ifstr(i) $(!STF_PLATFORM) == Mips
        set STF_PRNPLATFORM = "w32mips"
    else-ifstr(i) $(!STF_PLATFORM) == ppc
        set STF_PRNPLATFORM = "w32ppc"
    else-ifstr(i) $(!STF_PLATFORM) == Alpha
        set STF_PRNPLATFORM = "w32alpha"
    endif

    read-syms UiVars
    detect    UiVars

    ;
    ; Initialize the patch library support for the inf
    ;

    install   LoadPatchLibrary

    read-syms FreeSpace$(!STF_PLATFORM)

    ;
    ; Check for changes to the registry
    ;

    LibraryProcedure STATUS,$(!PATCHLIBHANDLE), CheckForRegistryCorruption
    ifstr(i) $(STATUS) != "OK"
         ifstr(i) $(BillboardPushed) == TRUE
             shell "subroutn.inf" PopBillboard
             set BillboardPushed = FALSE
         endif
         shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "FATAL" $(String6)
         goto patchnotdone
    endif

    ;
    ; if the Platform is not the same as the one supported by this patch
    ; diskette, inform the user and quit
    ;
    ifstr(i) $(STF_PLATFORM) != $(STF_PLATFORMDET)
         ifstr(i) $(BillboardPushed) == TRUE
             shell "subroutn.inf" PopBillboard
             set BillboardPushed = FALSE
         endif
         shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "FATAL" $(String1)
         goto patchnotdone
    endif

    ;
    ; Check to make sure we have admin privileges, if not print fatal error
    ;

    shell "registry.inf" CheckSetupModify
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        ; DEBUG
        ;
        ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Failed to shell CheckSetupModify"
        ;
        ; DEBUG END
        ifstr(i) $(BillboardPushed) == TRUE
            shell "subroutn.inf" PopBillboard
            set BillboardPushed = FALSE
        endif

        Debug-Output "shelling CheckSetupModify failed"
        goto patchnotdone
    else-ifstr(i) $($R0) != STATUS_SUCCESSFUL
        ifstr(i) $(BillboardPushed) == TRUE
            shell "subroutn.inf" PopBillboard
            set BillboardPushed = FALSE
        endif
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) "FATAL" $(String4)
        goto patchnotdone
    endif

    ;
    ; find out if the system we are patching is checked / free using GetCheckedFree
    ; and fail if we find a checked system.  ignore any errors in getting
    ; checked/free status since this is not important.
    ;
    shell "" GetCheckedFree
    ifint $($ShellCode) == $(!SHELL_CODE_OK)
        ifstr(i) $($R0) == "STATUS_SUCCESSFUL"
            ifstr(i) $($R1) == "checked"
                shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) "FATAL" $(String15)
                goto patchnotdone
            endif
        endif
    endif

    ;
    ; Get the build and patch version for the system.  If this is more than our patch
    ; version warn the user, allowing him to exit
    ;
    LibraryProcedure STATUS,$(!PATCHLIBHANDLE), CheckWindowsMajorVersion
    ifint $(STATUS) > $(STF_NT40_MAJORVER)
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) FATAL $(String18)
        goto patchnotdone
    else-ifint $(STATUS) = $(STF_NT40_MAJORVER)
        LibraryProcedure STATUS,$(!PATCHLIBHANDLE), CheckWindowsMinorVersion
        ifint $(STATUS) > $(STF_NT40_MINORVER)
            shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) FATAL $(String18)
            goto patchnotdone
        endif
    endif
    LibraryProcedure STATUS,$(!PATCHLIBHANDLE), CheckBuildVersion
    ifint $(STATUS) <= $(STF_NT35_BUILDVER)
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) FATAL $(String16)
        goto patchnotdone
    else-ifint $(STATUS) < $(STF_NT40_BUILDVER)
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) FATAL $(String17)
        goto patchnotdone
    else-ifint $(STATUS) > $(STF_NT40_BUILDVER)
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) FATAL $(String18)
        goto patchnotdone
    endif

    ;
    ; Make sure we're not updating an older Service Pack over a newer one
    ;
    shell "" GetCSDVersion
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        ifstr(i) $(BillboardPushed) == TRUE
            shell "subroutn.inf" PopBillboard
            set BillboardPushed = FALSE
        endif
        goto patchnotdone
    endif
    ifstr(i) $($R0) != "STATUS_SUCCESSFUL"
        goto patchnotdone
    else
        ifint $($R1) > $(!STF_CSDVER)
            ifstr(i) $(BillboardPushed) == TRUE
                shell "subroutn.inf" PopBillboard
                set BillboardPushed = FALSE
            endif
            shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) FATAL $(String8)
            goto patchnotdone
        endif
    endif

    ;
    ;  Still gotta check for Power Managed Version on PPC
    ;
    ifstr(i) $(!STF_PLATFORM) == ppc
        OpenRegKey $(!REG_H_LOCAL) "" "Software\Microsoft\Windows NT\CurrentVersion" 33554432 KeyCurrentVersion
        ifstr(i) $(KeyCurrentVersion) != ""
            GetRegValue $(KeyCurrentVersion) "PowerManagedVersion" PMVersionList
            ifstr(i) $(PMVersionList) != ""
                shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) FATAL $(String19)
                goto patchnotdone
            endif
            CloseRegKey $(KeyCurrentVersion)
        endif
    endif

    ;
    ; Check which language we're on.  If we're not updating the same language,
    ; get out.
    ;
    LibraryProcedure STATUS,$(!PATCHLIBHANDLE), GetLanguageType
    ifstr(i) $(STATUS) == ERROR
        goto patchnotdone
    else
        ifstr(i) $(STATUS) != $(STF_LANGUAGE_TYPE)
            shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) FATAL $(String20)
            goto patchnotdone
        endif
    endif

    ;
    ; Hack to clean up setup.log for FPNW so we can copy files
    ;
    ; LibraryProcedure STATUS,$(!PATCHLIBHANDLE), FixFPNWFiles

    ;
    ; Get the FPNW Path for 16-bit binaries
    ;
    LibraryProcedure STATUS,$(!PATCHLIBHANDLE), GetFPNWPathName
    ifstr(i) $(STATUS) != "FAILURE"
        set STF_FPNWSYSPATH = $(STATUS)
        set FPNWSysPathFound = TRUE
    endif

    ;
    ; Get the IE Path
    ;
    LibraryProcedure STATUS,$(!PATCHLIBHANDLE), GetIEPathName
    ifstr(i) $(STATUS) != "FAILURE"
        set STF_IEPATH = $(STATUS)
        set IEPathFound = TRUE
    endif

    ;
    ; Get the IIS .htr Path
    ;
    LibraryProcedure STATUS,$(!PATCHLIBHANDLE), GetHtrPathName
    ifstr(i) $(STATUS) != "FAILURE"
        set STF_HTRPATH = $(STATUS)
        set HtrPathFound = TRUE
    endif

skip_patchvercheck = +

    ;
    ; Get the NT DRIVE
    ;

    GetDriveInPath !STF_NTDRIVE $(!STF_WINDOWSSYSPATH)

    ;
    ; Check for enough disk space.
    ;

    ifint *($(VolumeFreeList), ~($(VolumeList), $(!STF_NTDRIVE))) < $(RequiredFreeWinnt)
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) FATAL $(String13a)$(RequiredFreeWinnt)$(String13b)$(!STF_NTDRIVE)$(String13c)
        goto patchnotdone
    endif

    ;
    ; get the product type we are running on
    ;

    set STF_PRODUCT = ""
    OpenRegKey $(!REG_H_LOCAL) "" "System\CurrentControlSet\Control\ProductOptions" 33554432 KeyProductOption
    ifstr(i) $(KeyProductOption) != ""
        GetRegValue $(KeyProductOption) "ProductType" ProductTypeList
        set TempProductType = *($(ProductTypeList),4)
        ifstr(i) $(TempProductType) == "winnt"
            set !STF_PRODUCT = WINNT
            set !PRODUCT_DIR = WINNT
        else-ifstr(i) $(TempProductType) == "lanmannt"
            set !STF_PRODUCT = LANMANNT
            set !PRODUCT_DIR = NTAS
        else-ifstr(i) $(TempProductType) == "servernt"
            set !STF_PRODUCT = SERVERNT
            set !PRODUCT_DIR = NTAS
        endif
        CloseRegKey $(KeyProductOptions)
    endif

    ;
    ; if we are unable to determine the product type print error and exit
    ;

    ifstr(i) $(STF_PRODUCT) == ""
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) FATAL $(String14)
        goto patchnotdone
    endif

    ;
    ; Find the hal and osloader destinations
    ;

    ifstr(i) $(!STF_PLATFORM) == I386
        set STF_HALDEST = $(!STF_WINDOWSSYSPATH)
        LibraryProcedure STATUS,$(!PATCHLIBHANDLE), GetOsLoaderDest

        ifstr(i) $(STATUS) == ERROR
            goto patchnotdone
        else
            set STF_OSLDEST = $(STATUS)
        endif

        ;
        ; Find out if the NTLDR on the system is a newer version than what
        ; we're trying to copy, and don't copy the Service Pack NTLDR if so
        ;

        set NtLdrName = $(STF_OSLDEST)"ntldr"
        LibraryProcedure STATUS,$(!PATCHLIBHANDLE), IsNTLDRVersionNewer $(NtLdrName)
        ifstr(i) $(STATUS) == "YES"
            set CopyLoader = FALSE
        endif

    else

        read-syms NVRAMVars
        detect    NVRAMVars
        LibraryProcedure STATUS,$(!PATCHLIBHANDLE), GetOsLoaderDest         +
                                                         $(SystemPartition) +
                                                         $(OsLoader)        +
                                                         $(OsLoadPartition) +
                                                         $(OsLoadFilename)
        ifstr(i) $(STATUS) == ERROR
            goto patchnotdone
        else
            set STF_OSLDEST = $(STATUS)
            set STF_HALDEST = $(STATUS)
        endif
    endif

    ;
    ; Figure out where IIS is installed, if it is installed
    ;

    OpenRegKey $(!REG_H_LOCAL) "" "Software\Microsoft\INetStp" 33554432 KeySvc
    ifstr(i) $(KeySvc) != ""
        GetRegValue $(KeySvc) "InstallPath" DestPathValue
        set !STF_IISPATH0 = *($(DestPathValue), 4)
        ifstr(i) $(STF_IISPATH0) != ""
            set IISPathFound = TRUE
	    set STF_IISPATH = $(STF_IISPATH0)
        endif
    endif
    CloseRegKey $(KeySvc)

    ;
    ; Determine if we have the 40 or 128 bit version of SSLSSPI.DLL and
    ; let the user choose whether to install the 40 over the 128.
    ;

    ;set FileToCheck = $(STF_WINDOWSSYSPATH)\sslsspi.dll
    ;LibraryProcedure STATUS,$(!LIBHANDLE),CheckFileExistance $(FileToCheck)
    ;ifstr(i) $(STATUS) == YES
    ;    LibraryProcedure Result $(!PATCHLIBHANDLE) GetSslFileDesc $(FileToCheck)
    ;    ifstr(i) $(Result) == "128"
    ;        shell "" QueryOkCancel $(String22)
    ;        ifstr(i) $($R1) == "CANCEL"
    ;            set CopySSL = FALSE
    ;        endif
    ;    endif
    ;endif

    ;
    ; Determine if we have the 40 or 128 bit version of SCHANNEL.DLL and
    ; let the user choose whether to install the 40 over the 128.
    ;

    set FileToCheck = $(STF_WINDOWSSYSPATH)\schannel.dll
    LibraryProcedure STATUS,$(!LIBHANDLE),CheckFileExistance $(FileToCheck)
    ifstr(i) $(STATUS) == YES
        LibraryProcedure Result $(!PATCHLIBHANDLE) GetSChannelFileDesc $(FileToCheck)
        ifstr(i) $(Result) == "128"
            shell "" QueryOkCancel $(String22)
            ifstr(i) $($R1) == "CANCEL"
                set CopySSL = FALSE
            endif
        endif
    endif

    ;
    ; Get the required information about keyed files
    ;

    read-syms FilesKeyedSections
    set KeyedClassKeys  = ^(FileKeyedClasses, 0)
    set KeyedClassFiles = ^(FileKeyedClasses, 1)

    set KeyedClassFilesList = {}
    ForListDo $(KeyedClassKeys)
        set TmpKey       = Files$($)
        set TmpFile      = #(FileKeyedClasses, $($), 1)
        set TmpFilePath  = $($(TmpKey))\$(TmpFile)
        set KeyedClassFilesList = >($(KeyedClassFilesList), $(TmpFilePath))
    EndForListDo

    LibraryProcedure STATUS,$(!PATCHLIBHANDLE), GetFileTypes $(KeyedClassFilesList)
    ifstr(i) $(STATUS) == ERROR
        goto patchnotdone
    else-ifstr(i) $(STATUS) == SETUPLOGNOTPRESENT
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) FATAL $(String11)
        goto patchnotdone
    else-ifstr(i) $(STATUS) == NTOSKRNLNOTFOUND
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) FATAL $(String21)
        goto patchnotdone
    else
        ForListDo $(KeyedClassKeys)
            set $($)Type = *($(STATUS), $(#))
        EndForListDo
    endif

    ;
    ; Warn the user about the patch process..
    ;

    ifstr(i) $(BillboardPushed) == TRUE
        shell "subroutn.inf" PopBillboard
        set BillboardPushed = FALSE
    endif

    ifstr(i) $(Unattended) != TRUE
        shell "" QueryOkCancel $(String9)
        ifstr(i) $($R1) == "OK"
        else
            set String = $(String12)
            goto finish2
        endif
    endif

    shell "subroutn.inf" PushBillboard STATUSDLG $(Billboard2)
    set BillboardPushed = TRUE

    ;
    ; initialize copy
    ;

    set MoveFileExList  = {}


    ;
    ; Run through the directory list adding files to the copy list
    ;

    read-syms FileSections
    set FileSectionsList = ^(FileSections, 0)
    set FileSource  = $(!STF_SRCDIR)

    ForListDo $(FileSectionsList)
        set FileSection = $($)
        set FileDest    = $($($))
        set FileList    = ^($(FileSection), 0)
        ForListDo $(FileList)
            set FileKey          = $($)
            set File             = #($(FileSection), $(FileKey), 2)
            set FileDestFullPath = $(FileDest)\$(File)

            ;
            ; Check to see if file exists, if it is does not exist, it doesn't
            ; need to be copied over

            LibraryProcedure STATUS,$(!LIBHANDLE),CheckFileExistance $(FileDestFullPath)
            ifstr(i) $(STATUS) == YES


                ; DEBUG
                ;
                ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Examining to see if file opened excl: "$(FileDestFullPath)
                ;
                ; DEBUG END

                LibraryProcedure STATUS, $(!PATCHLIBHANDLE), IsFileOpenedExclusive $(FileDestFullPath)
                ifstr(i) $(STATUS) == ERROR
                    goto patchnotdone
                else
                    ifstr(i) $(STATUS) == "YES"
                        LibraryProcedure NEWFILE, $(!PATCHLIBHANDLE), GenerateTemporary $(FileDest)
                        ifstr(i) $(NEWFILE) == ERROR
                            goto patchnotdone
                        else
                            set FileComp = {$(FileDest)\$(NEWFILE), $(FileDestFullPath)}

                            ; DEBUG
                            ;
                            ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Adding to movefile ex list: "$(FileComp)
                            ;
                            ; DEBUG END

                            set MoveFileExList = >($(MoveFileExList), $(FileComp))
                        endif
                    else
                        set NEWFILE = $(File)
                    endif

                    ; DEBUG
                    ;
                    ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Copying File Section: "$(FileSection)" : Key: "$(FileKey)" Source: "$(FileSource)" Dest: "$(FileDest)" rename = "$(NEWFILE)
                    ;
                    ; DEBUG END

                    install Install-File
                endif
            endif
        EndForListDo
    EndForListDO

    ;
    ; Add the keyed sections to the copy list
    ;

    set FileSource  = $(!STF_SRCDIR)
    ForListDo $(KeyedClassKeys)
        set FileSection = Files$($)
        set FileDest    = $($(FileSection))
        set FileKey     = $($($)Type)

        set KeyedClassChoices = ^(Files$($), 0)
        ifcontains(i) $(FileKey) in $(KeyedClassChoices)
            set File             = #(FileKeyedClasses, $($), 1)
            set FileDestFullPath = $(FileDest)\$(File)
            ;
            ; Check to see if file exists, if it is does not exist, it doesn't
            ; need to be copied over

            LibraryProcedure STATUS,$(!LIBHANDLE),CheckFileExistance $(FileDestFullPath)
            ifstr(i) $(STATUS) == YES


                ; DEBUG
                ;
                ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Examining to see if file opened excl: "$(FileDestFullPath)
                ;
                ; DEBUG END

                LibraryProcedure STATUS, $(!PATCHLIBHANDLE), IsFileOpenedExclusive $(FileDestFullPath)
                ifstr(i) $(STATUS) == ERROR
                    goto patchnotdone
                else
                    ifstr(i) $(STATUS) == "YES"
                        LibraryProcedure NEWFILE, $(!PATCHLIBHANDLE), GenerateTemporary $(FileDest)
                        ifstr(i) $(NEWFILE) == ERROR
                            goto patchnotdone
                        else
                            set FileComp = {$(FileDest)\$(NEWFILE), $(FileDestFullPath)}

                            ; DEBUG
                            ;
                            ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Adding to movefile ex list: "$(FileComp)
                            ;
                            ; DEBUG END

                            set MoveFileExList = >($(MoveFileExList), $(FileComp))
                        endif
                    else
                        set NEWFILE = $(File)
                    endif

                    ; DEBUG
                    ;
                    ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Copying File Section: "$(FileSection)" : Key: "$(FileKey)" Source: "$(FileSource)" Dest: "$(FileDest)" rename = "$(NEWFILE)
                    ;
                    ; DEBUG END

                    install Install-File
                endif
            endif
        endif
    EndForListDo

    ;
    ; add product specific files to the copy list
    ;
    ; ServerNT and LanmanNT share the same files
    ;
    ifstr(i) $(STF_PRODUCT) == "WINNT"
        set TEMP_PRODUCT = WINNT
    else
        set TEMP_PRODUCT = LANMANNT
    endif

    read-syms FileSections$(TEMP_PRODUCT)
    set FileSectionsList = ^(FileSections$(TEMP_PRODUCT), 0)
    set FileSource  = $(!STF_SRCDIR)$(PRODUCT_DIR)
    ForListDo $(FileSectionsList)
        set FileSection = $($)
        set FileDest    = $($($))
        set FileList    = ^($(FileSection), 0)
        ForListDo $(FileList)
            set FileKey      = $($)
            set File         = #($(FileSection), $(FileKey), 2)
            set FileDestFullPath = $(FileDest)\$(File)

            ;
            ; Check to see if file exists, if it is does not exist, it doesn't
            ; need to be copied over

            LibraryProcedure STATUS,$(!LIBHANDLE),CheckFileExistance $(FileDestFullPath)
            ifstr(i) $(STATUS) == YES


                ; DEBUG
                ;
                ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Examining to see if file opened excl: "$(FileDestFullPath)
                ;
                ; DEBUG END

                LibraryProcedure STATUS, $(!PATCHLIBHANDLE), IsFileOpenedExclusive $(FileDestFullPath)
                ifstr(i) $(STATUS) == ERROR
                    goto patchnotdone
                else
                    ifstr(i) $(STATUS) == "YES"
                        LibraryProcedure NEWFILE, $(!PATCHLIBHANDLE), GenerateTemporary $(FileDest)
                        ifstr(i) $(NEWFILE) == ERROR
                            goto patchnotdone
                        else
                            set FileComp = {$(FileDest)\$(NEWFILE), $(FileDestFullPath)}

                            ; DEBUG
                            ;
                            ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Adding to movefile ex list: "$(FileComp)
                            ;
                            ; DEBUG END

                            set MoveFileExList = >($(MoveFileExList), $(FileComp))
                        endif
                    else
                        set NEWFILE = $(File)
                    endif

                    ; DEBUG
                    ;
                    ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Copying File Section: "$(FileSection)" : Key: "$(FileKey)" Source: "$(FileSource)" Dest: "$(FileDest)" rename = "$(NEWFILE)
                    ;
                    ; DEBUG END

                    install Install-File
                endif
            endif
        EndForListDo
    EndForListDO


    ifstr(i) $(BillboardPushed) == TRUE
        shell "subroutn.inf" PopBillboard
        set BillboardPushed = FALSE
    endif

    ;
    ; add the files which are always copied
    ;
    read-syms FileSectionsCopyAlways
    set FileSectionsList = ^(FileSectionsCopyAlways, 0)
    set FileSource  = $(!STF_SRCDIR)

    ForListDo $(FileSectionsList)
        set FileSection = $($)
        set FileDest    = $($($))
        set FileList    = ^($(FileSection), 0)
        ForListDo $(FileList)
            set FileKey = $($)
            set File    = #($(FileSection), $(FileKey), 2)
            set NEWFILE = $(File)
            set FileDestFullPath = $(FileDest)\$(File)
            install Install-File
        EndForListDo
    EndForListDO

    ; add the platform specific files which are copied always
    ; these files are for WINNT only or LANMANNT only.
    ; files which are common to both should be added to the
    ; FileSectionsCopyAlways section.

    read-syms FileSectionsCopyAlways$(TEMP_PRODUCT)
    set FileSectionsList = ^(FileSectionsCopyAlways$(TEMP_PRODUCT), 0)
    set FileSource  = $(!STF_SRCDIR)$(PRODUCT_DIR)

    ForListDo $(FileSectionsList)
        set FileSection = $($)
        set FileDest    = $($($))
        set FileList    = ^($(FileSection), 0)
        ForListDo $(FileList)
            set FileKey = $($)
            set File    = #($(FileSection), $(FileKey), 2)
            set NEWFILE = $(File)
            set FileDestFullPath = $(FileDest)\$(File)
            install Install-File
        EndForListDo
    EndForListDO

    ; if this is an FPNW system, then we need to copy the FPNW files.

    ifstr(i) $(FPNWSysPathFound) == TRUE
        read-syms FileSectionsFPNW
        set FileSectionsList = ^(FileSectionsFPNW, 0)
        set FileSource  = $(!STF_SRCDIR)
        ForListDo $(FileSectionsList)
            set FileSection = $($)
            set FileDest    = $($($))
            set FileList    = ^($(FileSection), 0)
            ForListDo $(FileList)
                set FileKey      = $($)
                set File         = #($(FileSection), $(FileKey), 2)
                set FileDestFullPath = $(FileDest)\$(File)
                LibraryProcedure STATUS,$(!LIBHANDLE),CheckFileExistance $(FileDestFullPath)
                ifstr(i) $(STATUS) == YES
                    LibraryProcedure STATUS, $(!PATCHLIBHANDLE), IsFileOpenedExclusive $(FileDestFullPath)
                    ifstr(i) $(STATUS) == ERROR
                        goto patchnotdone
                    else
                        ifstr(i) $(STATUS) == "YES"
                            LibraryProcedure NEWFILE, $(!PATCHLIBHANDLE), GenerateTemporary $(FileDest)
                            ifstr(i) $(NEWFILE) == ERROR
                                goto patchnotdone
                            else
                                set FileComp = {$(FileDest)\$(NEWFILE), $(FileDestFullPath)}
                                set MoveFileExList = >($(MoveFileExList), $(FileComp))
                            endif
                        else
                            set NEWFILE = $(File)
                        endif
                        install Install-File
                    endif
                endif
            EndForListDo
        EndForListDO
    endif

    ; if NTLDR is a newer version than what we're tring to install, don't copy it

    ifstr(i) $(CopyLoader) == TRUE
        read-syms FileSectionsOsLoader
        set FileSectionsList = ^(FileSectionsOsLoader, 0)
        set FileSource  = $(!STF_SRCDIR)
        ForListDo $(FileSectionsList)
            set FileSection = $($)
            set FileDest    = $($($))
            set FileList    = ^($(FileSection), 0)
            ForListDo $(FileList)
                set FileKey      = $($)
                set File         = #($(FileSection), $(FileKey), 2)
                set FileDestFullPath = $(FileDest)\$(File)
                LibraryProcedure STATUS,$(!LIBHANDLE),CheckFileExistance $(FileDestFullPath)
                ifstr(i) $(STATUS) == YES
                    LibraryProcedure STATUS, $(!PATCHLIBHANDLE), IsFileOpenedExclusive $(FileDestFullPath)
                    ifstr(i) $(STATUS) == ERROR
                        goto patchnotdone
                    else
                        ifstr(i) $(STATUS) == "YES"
                            LibraryProcedure NEWFILE, $(!PATCHLIBHANDLE), GenerateTemporary $(FileDest)
                            ifstr(i) $(NEWFILE) == ERROR
                                goto patchnotdone
                            else
                                set FileComp = {$(FileDest)\$(NEWFILE), $(FileDestFullPath)}
                                set MoveFileExList = >($(MoveFileExList), $(FileComp))
                            endif
                        else
                            set NEWFILE = $(File)
                        endif
                        install Install-File
                    endif
                endif
            EndForListDo
        EndForListDO
    endif

    ;
    ; Copy the IIS files, if IIS is installed
    ;

    ifstr(i) $(IISPathFound) == TRUE
        read-syms FileSectionsIIS
        set FileSectionsList = ^(FileSectionsIIS, 0)
        set FileSource  = $(!STF_SRCDIR)
        ForListDo $(FileSectionsList)
            set FileSection = $($)
            set FileDest    = $($($))
            set FileList    = ^($(FileSection), 0)
            ForListDo $(FileList)
                set FileKey      = $($)
                set File         = #($(FileSection), $(FileKey), 2)
                set FileDestFullPath = $(FileDest)\$(File)
                LibraryProcedure STATUS,$(!LIBHANDLE),CheckFileExistance $(FileDestFullPath)
                ifstr(i) $(STATUS) == YES
                    LibraryProcedure STATUS, $(!PATCHLIBHANDLE), IsFileOpenedExclusive $(FileDestFullPath)
                    ifstr(i) $(STATUS) == ERROR
                        goto patchnotdone
                    else
                        ifstr(i) $(STATUS) == "YES"
                            LibraryProcedure NEWFILE, $(!PATCHLIBHANDLE), GenerateTemporary $(FileDest)
                            ifstr(i) $(NEWFILE) == ERROR
                                goto patchnotdone
                            else
                                set FileComp = {$(FileDest)\$(NEWFILE), $(FileDestFullPath)}
                                set MoveFileExList = >($(MoveFileExList), $(FileComp))
                            endif
                        else
                            set NEWFILE = $(File)
                        endif
                        install Install-File
                    endif
                endif
            EndForListDo
        EndForListDO
        read-syms FileSectionsIISAdmin
        set FileSectionsList = ^(FileSectionsIISAdmin, 0)
        set FileSource  = $(!STF_SRCDIR)
        ForListDo $(FileSectionsList)
            set FileSection = $($)
            set FileDest    = $($($))
            set FileList    = ^($(FileSection), 0)
            ForListDo $(FileList)
                set FileKey      = $($)
                set File         = #($(FileSection), $(FileKey), 2)
                set FileDestFullPath = $(FileDest)\$(File)
                LibraryProcedure STATUS,$(!LIBHANDLE),CheckFileExistance $(FileDestFullPath)
                ifstr(i) $(STATUS) == YES
                    LibraryProcedure STATUS, $(!PATCHLIBHANDLE), IsFileOpenedExclusive $(FileDestFullPath)
                    ifstr(i) $(STATUS) == ERROR
                        goto patchnotdone
                    else
                        ifstr(i) $(STATUS) == "YES"
                            LibraryProcedure NEWFILE, $(!PATCHLIBHANDLE), GenerateTemporary $(FileDest)
                            ifstr(i) $(NEWFILE) == ERROR
                                goto patchnotdone
                            else
                                set FileComp = {$(FileDest)\$(NEWFILE), $(FileDestFullPath)}
                                set MoveFileExList = >($(MoveFileExList), $(FileComp))
                            endif
                        else
                            set NEWFILE = $(File)
                        endif
                        install Install-File
                    endif
                endif
            EndForListDo
        EndForListDO
    endif

    ;
    ; Copy the IE files
    ;

    ifstr(i) $(IEPathFound) == TRUE
        read-syms FileSectionsIE
        set FileSectionsList = ^(FileSectionsIE, 0)
        set FileSource  = $(!STF_SRCDIR)
        ForListDo $(FileSectionsList)
            set FileSection = $($)
            set FileDest    = $($($))
            set FileList    = ^($(FileSection), 0)
            ForListDo $(FileList)
                set FileKey      = $($)
                set File         = #($(FileSection), $(FileKey), 2)
                set FileDestFullPath = $(FileDest)\$(File)
                LibraryProcedure STATUS,$(!LIBHANDLE),CheckFileExistance $(FileDestFullPath)
                ifstr(i) $(STATUS) == YES
                    LibraryProcedure STATUS, $(!PATCHLIBHANDLE), IsFileOpenedExclusive $(FileDestFullPath)
                    ifstr(i) $(STATUS) == ERROR
                        goto patchnotdone
                    else
                        ifstr(i) $(STATUS) == "YES"
                            LibraryProcedure NEWFILE, $(!PATCHLIBHANDLE), GenerateTemporary $(FileDest)
                            ifstr(i) $(NEWFILE) == ERROR
                                goto patchnotdone
                            else
                                set FileComp = {$(FileDest)\$(NEWFILE), $(FileDestFullPath)}
                                set MoveFileExList = >($(MoveFileExList), $(FileComp))
                            endif
                        else
                            set NEWFILE = $(File)
                        endif
                        install Install-File
                    endif
                endif
            EndForListDo
        EndForListDO
    endif

    ;
    ; Copy the IIS .htr files
    ;

    ifstr(i) $(HtrPathFound) == TRUE
        read-syms FileSectionsHtr
        set FileSectionsList = ^(FileSectionsHtr, 0)
        set FileSource  = $(!STF_SRCDIR)
        ForListDo $(FileSectionsList)
            set FileSection = $($)
            set FileDest    = $($($))
            set FileList    = ^($(FileSection), 0)
            ForListDo $(FileList)
                set FileKey      = $($)
                set File         = #($(FileSection), $(FileKey), 2)
                set FileDestFullPath = $(FileDest)\$(File)
                LibraryProcedure STATUS,$(!LIBHANDLE),CheckFileExistance $(FileDestFullPath)
                ifstr(i) $(STATUS) == YES
                    LibraryProcedure STATUS, $(!PATCHLIBHANDLE), IsFileOpenedExclusive $(FileDestFullPath)
                    ifstr(i) $(STATUS) == ERROR
                        goto patchnotdone
                    else
                        ifstr(i) $(STATUS) == "YES"
                            LibraryProcedure NEWFILE, $(!PATCHLIBHANDLE), GenerateTemporary $(FileDest)
                            ifstr(i) $(NEWFILE) == ERROR
                                goto patchnotdone
                            else
                                set FileComp = {$(FileDest)\$(NEWFILE), $(FileDestFullPath)}
                                set MoveFileExList = >($(MoveFileExList), $(FileComp))
                            endif
                        else
                            set NEWFILE = $(File)
                        endif
                        install Install-File
                    endif
                endif
            EndForListDo
        EndForListDO
    endif

    ;
    ; Copy the 40 bit SSLSSPI.DLL, if the user said it's OK
    ;

    ifstr(i) $(CopySSL) == TRUE
	read-syms FileSectionsSSL
	set FileSectionsList = ^(FileSectionsSSL, 0)
        set FileSource  = $(!STF_SRCDIR)
        ForListDo $(FileSectionsList)
            set FileSection = $($)
            set FileDest    = $($($))
            set FileList    = ^($(FileSection), 0)
            ForListDo $(FileList)
                set FileKey      = $($)
                set File         = #($(FileSection), $(FileKey), 2)
                set FileDestFullPath = $(FileDest)\$(File)
                LibraryProcedure STATUS,$(!LIBHANDLE),CheckFileExistance $(FileDestFullPath)
                ifstr(i) $(STATUS) == YES
                    LibraryProcedure STATUS, $(!PATCHLIBHANDLE), IsFileOpenedExclusive $(FileDestFullPath)
                    ifstr(i) $(STATUS) == ERROR
                        goto patchnotdone
                    else
                        ifstr(i) $(STATUS) == "YES"
                            LibraryProcedure NEWFILE, $(!PATCHLIBHANDLE), GenerateTemporary $(FileDest)
                            ifstr(i) $(NEWFILE) == ERROR
                                goto patchnotdone
                            else
                                set FileComp = {$(FileDest)\$(NEWFILE), $(FileDestFullPath)}
                                set MoveFileExList = >($(MoveFileExList), $(FileComp))
                            endif
                        else
                            set NEWFILE = $(File)
                        endif
                        install Install-File
                    endif
                endif
            EndForListDo
        EndForListDO
    endif

    ;
    ; Do the copy
    ;

    read-syms ProgressCopy$(!STF_LANGUAGE)
    install   Install-DoCopy
    ifstr(i) $(STF_INSTALL_OUTCOME) == "STF_USERQUIT"
        goto patchnotdone
    else-ifstr(i) $(STF_INSTALL_OUTCOME) == "STF_FAILURE"
        goto patchnotdone
    endif

    ;
    ; Process the Attributes List
    ;
    set FileSection = "FileAttributes";
    set FileList    = ^(FileSection, 0)
    ForListDo $(FileList)
        set FileKey          = $($)
        set File             = #($(FileSection), $(FileKey), 2)
        set FileDest         = #($(FileSection), $(FileKey), 3)
        set FilePerms        = #($(FileSection), $(FileKey), 4)
        set FileDestFullPath = $(FileDest)\$(File)

        ifstr(i) $(FilePerms) != ""
            LibraryProcedure STATUS,$(!PATCHLIBHANDLE),ChangeFileAttributes $(FilePerms) $(FileDestFullPath)
        endif
    EndForListDo

processmovefileex=+
    ;
    ; Process MoveFileExList
    ;

    ForListDo $(MoveFileExList)
        ;
        set ExistingPath = *($($), 1)
        set NewPath      = *($($), 2)

        ; DEBUG
        ;
        ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "CopyFileOnReboot "$(ExistingPath)" to "$(NewPath)
        ;
        ; DEBUG END

        LibraryProcedure STATUS, $(!PATCHLIBHANDLE), CopyFileOnReboot $(ExistingPath) $(NewPath)
        ifstr(i) $(STATUS) == ERROR
            goto patchnotdone
        endif
    EndForListDo

    ifstr(i) $(!STF_PLATFORM) == I386
        ;
        ;    On x86 make sure that ntldr is uncompressed
        ;
        set NtLdrPath = $(STF_OSLDEST)"ntldr"
        LibraryProcedure STATUS, $(!PATCHLIBHANDLE), ForceFileNoCompress $(NtLdrPath)
        ifstr(i) $(STATUS) == ERROR
            goto patchnotdone
        endif
    endif

patchdone =+
    ;
    ; Restore setup.log
    ;
    ; LibraryProcedure STATUS,$(!PATCHLIBHANDLE), RestoreSetupLog

    ifstr(i) $(BillboardPushed) == TRUE
        shell "subroutn.inf" PopBillboard
        set BillboardPushed = FALSE
    endif

    ;
    ; do the registry modifications needed
    ;

    shell "" DoRegistryModifications $(!STF_CSDVER)
    ifstr(i) $(Unattended) != TRUE
        read-syms SetupDoneDlg$(!STF_LANGUAGE)
        ui start "SetupDone"
        ifstr(i) $(DLGEVENT) == "CONTINUE"
            ui pop 1
            goto rebootend
        else
            ui pop 1
            goto finish1
        endif
    else
        goto rebootend
    endif

patchnotdone =+
    ;
    ; Restore setup.log
    ;
    ; LibraryProcedure STATUS,$(!PATCHLIBHANDLE), RestoreSetupLog

    set String = $(String2)
finish2 =+
    ifstr(i) $(BillboardPushed) == TRUE
        shell "subroutn.inf" PopBillboard
        set BillboardPushed = FALSE
    endif

    shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "FATAL" $(String)
    goto finish1

finish1 =+
    ;
    ; Free the library support
    ;

    install   FreeSetupLibrary

finish =+

    install   FreePatchLibrary
    exit

rebootend =+
    set Reboot = YES
    ifstr(i) $(Unattended) != TRUE
	install	Install-Shutdown
    else
	ifstr(i) $(ForceClose) != TRUE
	    set ForceAppsClosed = NO
	else
	    set ForceAppsClosed = YES
	endif
	install Install-Shutdown2
    endif
    goto finish1
    exit


;-----------------------------------------------------------------------
; INSTALL HELPERS
;-----------------------------------------------------------------------

[LoadPatchLibrary]
    LoadLibrary "x" $(CWD)\patchdll.dll !PATCHLIBHANDLE
    exit

[FreePatchLibrary]
    ifstr(i) $(!PATCHLIBHANDLE) != ""
        FreeLibrary $(!PATCHLIBHANDLE)
    endif
    exit

[LoadSetupLibrary]
    LoadLibrary "x" $(!STF_CWDDIR)setupdll.dll !LIBHANDLE
    exit

[FreeSetupLibrary]
    ifstr(i) $(!LIBHANDLE) != ""
        FreeLibrary $(!LIBHANDLE)
    endif
    exit

[Install-File]
    set STF_VITAL = ""
    AddSectionKeyFileToCopyList $(FileSection) $(FileKey) $(FileSource) $(FileDest)
    exit

[Install-DoCopy]
    CopyFilesInCopyList
    exit


[Install-Shutdown]
    ;
    LibraryProcedure STATUS,$(!LIBHANDLE),ShutdownSystem $(Reboot)
    exit

[Install-Shutdown2]
    LibraryProcedure STATUS,$(!PATCHLIBHANDLE),ShutdownSystem2 $(Reboot) $(ForceAppsClosed)
    exit

;-----------------------------------------------------------------------
; REGISTRY SUBROUTINES
;-----------------------------------------------------------------------

[RegistryConstants]

    MaskAllAccess          = 33554432
    NoTitle                = 0
    RegLastError           = $(!REG_ERROR_SUCCESS)
    CurrentControlSet      = "SYSTEM\CurrentControlSet"
    ServicesBaseName       = $(CurrentControlSet)"\Services"
    NetbtKeyPath           = $(ServicesBaseName)"\Netbt"

;-----------------------------------------------------------------------
; ROUTINE:      DoRegistryModifications
;
; DESCRIPTION:  Does the registry modifications needed.
;               - Sets the compatibility flags for the postcript stuff
;               - Creates an entry for the WinNT software.
;
; INPUTS:       $0:  CSD Version #
;
; OUTPUTS:      $R0: Status: STATUS_SUCCESSFUL
;                            STATUS_FAILED
;
;------------------------------------------------------------------------

[DoRegistryModifications]

    set Status = STATUS_FAILED
    read-syms RegistryConstants

    ;
    ; Form the path up to the version key
    ;

    set KeyPath   = { +
                     {SYSTEM,            $(NoTitle), $(MaskAllAccess)}, +
                     {CurrentControlSet, $(NoTitle), $(MaskAllAccess)}, +
                     {Control,           $(NoTitle), $(MaskAllAccess)}, +
                     {Windows,           $(NoTitle), $(MaskAllAccess)}, +
                    }

    ;
    ; Form the value info structures for the WinNT entry
    ; Note that for NT 3.5, the CSD version goes into the high order word
    ;

    set KeyValues = { +
                     {CSDVersion, $(NoTitle), $(!REG_VT_DWORD), $($0) } +
                    }


    shell "registry.inf" CreateKey $(!REG_H_LOCAL) $(KeyPath) $(KeyValues)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto endCSDVersionCreate
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        goto endCSDVersionCreate
    else
        CloseRegKey $($R1)
    endif

    set Status = STATUS_SUCCESSFUL
endCSDVersionCreate = +
    Return $(Status)




;-----------------------------------------------------------------------
; ROUTINE:      GetCSDVersion
;
; DESCRIPTION:  Reads the software entry to find out what the CSD Patch Version
;               is
;
; INPUTS:       $0:  None
;
; OUTPUTS:      $R0: Status: STATUS_SUCCESSFUL
;                            STATUS_FAILED
;
;               $R1: CSDVersion
;
;------------------------------------------------------------------------

[GetCSDVersion]

    set Status = STATUS_SUCCESSFUL
    read-syms RegistryConstants
    set CSDVersion = 0

    ;
    ; Open the HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Windows
    ; key

    set KeyName = "SYSTEM\CurrentControlSet\Control\Windows"
    OpenRegKey $(!REG_H_LOCAL) "" $(KeyName) $(!REG_KEY_READ) KeyHandle
    ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
        Debug-Output "REGISTRY.INF: Couldn't open windows nt software key for read access"
        goto end_GetCSDVersion
    endif

    ;
    ; read the csdversion entry
    ;

    GetRegValue $(KeyHandle) "CSDVersion" CSDVersionValue
    ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
        CloseRegKey $(KeyHandle)
        goto end_GetCSDVersion
    endif

    set CSDVersion =  *($(CSDVersionValue), 4)
    CloseRegKey $(KeyHandle)
end_GetCSDVersion = +
    Return $(Status) $(CSDVersion)


;-----------------------------------------------------------------------
; ROUTINE:      GetCheckedFree
;
; DESCRIPTION:  Reads the software entry to find out whether the system
;               is checked / free.
;
; INPUTS:       $0:  None
;
; OUTPUTS:      $R0: Status: STATUS_SUCCESSFUL
;                            STATUS_FAILED
;
;               $R1: Checked | Free
;
;------------------------------------------------------------------------

[GetCheckedFree]

    set Status = STATUS_SUCCESSFUL
    read-syms RegistryConstants
    set System = Free

    ;
    ; Open the HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion
    ; key

    set KeyName = "Software\Microsoft\Windows NT\CurrentVersion"
    OpenRegKey $(!REG_H_LOCAL) "" $(KeyName) $(!REG_KEY_READ) KeyHandle
    ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
        Debug-Output "REGISTRY.INF: Couldn't open windows nt software key for read access"
        goto end_GetCheckedFree
    endif

    ;
    ; read the currenttype value
    ;

    GetRegValue $(KeyHandle) "CurrentType" CurrentTypeValue
    ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
        CloseRegKey $(KeyHandle)
        goto end_GetCheckedFree
    endif

    ;
    ; split the currenttype value and see if the split string has "free" or
    ; "checked" in it
    ;

    Split-String *($(CurrentTypeValue), 4) " " CurrentTypeList
    ForListDo $(CurrentTypeList)
       ifstr(i) $($) == "free"
          set System = free
       else-ifstr(i) $($) == "checked"
          set System = checked
       endif
    EndForListDo

    CloseRegKey $(KeyHandle)
end_GetCheckedFree = +
    Return $(Status) $(System)


;-----------------------------------------------------------------------
; ROUTINE:      QueryOkCancel
;
; DESCRIPTION:  This routine lets the user query OK / Cancel giving OK as
;               default
;
; INPUTS:       $0:  MessageText.
;
; OUTPUTS:      $R0: STATUS:   STATUS_SUCCESSFUL |
;                              STATUS_NOLANGUAGE
;                              STATUS_FAILED
;
;               $R1: DLGEVENT: OK | CANCEL
;
;------------------------------------------------------------------------

[QueryOkCancel]

    set DlgText = $($0)
    read-syms QueryOKCancelDlg$(!STF_LANGUAGE)

    ui start "SetupMessage"
    ifstr(i) $(DLGEVENT) == "OK"
        set Status     = STATUS_SUCCESSFUL
        set UserAction = $(DLGEVENT)

    else-ifstr(i) $(DLGEVENT) == "CANCEL"
        set Status     = STATUS_SUCCESSFUL
        set UserAction = $(DLGEVENT)
    else
        set Status     = STATUS_FAILED
        set UserAction = "CANCEL"
    endif
    Return $(Status) $(UserAction)

