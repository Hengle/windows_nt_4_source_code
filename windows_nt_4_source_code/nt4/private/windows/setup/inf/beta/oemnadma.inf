; **********************************************************************
;
; OEMSETUP.INF 
;
; Copyright (c) Madge Networks Ltd. 1994
;
; MADGE Smart Ringnode Driver installer for MdgMPort.SYS
;
; VeRsIoN=OEMSETUP.INF 3.04.30 (for use with MdgMPort.SYS 2.04.30)
; 
; **********************************************************************

; ----------------------------------------------------------------------
; Mandatory configuration information.
; ----------------------------------------------------------------------

[Identification]
    OptionType = NetAdapter

[PlatformsSupported]
    MCA
    ISA
    EISA
    PCI
    PCMCIA
    "Jazz-Internal Bus"


[Options]
    ;MSMDGMPAUTO
    MSMDGMPISA
    MSMDGMPATP
    MSMDGMPISAC
    MSMDGMPISACP
    MSMDGMPPC
    MSMDGMPSM16
    MSMDGMPPNP
    MSMDGMPMCA
    MSMDGMPMC32
    MSMDGMPEISA
    MSMDGMPPCI
    MSMDGMPPCIBM
    MSMDGMPPCMCIA

[OptionsISA]
    ;MSMDGMPAUTO
    MSMDGMPISA
    MSMDGMPATP
    MSMDGMPISAC
    MSMDGMPISACP
    MSMDGMPPC
    MSMDGMPSM16
    MSMDGMPPNP

[OptionsMCA]
    ;MSMDGMPAUTO
    MSMDGMPMCA
    MSMDGMPMC32

[OptionsEISA]
    ;MSMDGMPAUTO
    MSMDGMPEISA
    MSMDGMPISA
    MSMDGMPATP
    MSMDGMPISAC
    MSMDGMPISACP
    MSMDGMPPC
    MSMDGMPSM16
    MSMDGMPPNP


[OptionsPCI]
    ;MSMDGMPAUTO
    MSMDGMPPCI
    MSMDGMPPCIBM

[OptionsPCMCIA]
    ;MSMDGMPAUTO
    MSMDGMPPCMCIA

;-----------------------------------------------------------------------
; Adapter options that require a slot number and a transfer method.
; Others require an IO location a transfer method and an IRQ number.
;-----------------------------------------------------------------------

[SlotNumberOnlyOptions]
    MSMDGMPEISA
    MSMDGMPMCA
    MSMDGMPMC32
    MSMDGMPPCI
    MSMDGMPPCIBM

;-----------------------------------------------------------------------
; Adapter options that support MMIO.
;-----------------------------------------------------------------------

[MmioOptions]
    MSMDGMPPCI

    
; ----------------------------------------------------------------------
; Constants specific to the driver.
; ----------------------------------------------------------------------

[FileConstants]

;
;  File names, etc.
;

DialogDllName = "MDGMPDLG.DLL"
SoftwareType  = "driver"
Exit_Code     = 0

;
; Product Information.
;

Manufacturer        = "Madge"
ProductMajorVersion = "4"
ProductMinorVersion = "0"
ProductRevision     = ".00"
ProductVersion      = $(ProductMajorVersion)"."$(ProductMinorVersion)$(ProductRevision)

;
; Software information.
;

ProductSoftwareName     = "MadgeMPort"
ProductSoftwareImagePath = "%SystemRoot%\system32\drivers\MdgMPort.sys"

NetRuleSoftwareType     = "mdgtrSys ndisDriver mdgtrDriver"
NetRuleSoftwareUse      = $(SoftwareType)
NetRuleSoftwareBindForm = """mdgtrSys"" yes no container"
NetRuleSoftwareClass    = {"mdgtrDriver basic"}
NetRuleSoftwareBindable = {"mdgtrDriver mdgtrAdapter non exclusive 100"}

;
; Hardware information.
;

ProductHardwareName         = "MadgeMPort"
NetRuleHardwareType         = "mdgtr mdgtrAdapter"
NetRuleHardwareBindForm     = " yes yes container"
NetRuleHardwareClass        = {"mdgtrAdapter basic"}
ProductOpSupport     = 134 ; 0x0086 ; Display,Removable,Properties,Not Updatable

;
; Registry Key.
;

ProductKeyName  = $(!NTN_SoftwareBase)"\"$(Manufacturer)"\"$(ProductSoftwareName)"\CurrentVersion"
ParamKeyName    = $(!NTN_ServiceBase)"\"$(ProductHardwareName)"\Parameters"

;
; EventLog Message File.
;

MadgeEventLogFile = $(ProductSoftwareImagePath)

; ---------------------------------------------------------------------
; General constants.
; ---------------------------------------------------------------------

[GeneralConstants]

;
;  File names, etc.
;

UtilityInf    = "UTILITY.INF"
SubroutineInf = "SUBROUTN.INF"
ParamInf      = "NCPARAM.INF"

;
; Program flow control variables.
;

From      = ""
To        = ""

;
; Return codes; Exit_Code is set to one of these
;

ExitCodeOk     = 0
ExitCodeCancel = 1
ExitCodeFatal  = 2

;
; Miscellaneous.
;

MAXIMUM_ALLOWED    = 33554432
RegistryErrorIndex = NO_ERROR
KeyNull            = ""
KeyProduct         = ""
KeyParameters      = ""

TRUE    = 1
FALSE   = 0
NoTitle = 0

ExitState         = "Active"
OldVersionExisted = $(FALSE)

DriverPath      = $(!STF_NTPATH)\drivers

;
; Resource values returned by the detection DLL, so do not change them.
;

VALUE_UNKNOWN   = 65535
GENERAL_PIO     = 0
GENERAL_DMA     = 500
GENERAL_MMIO    = 501

;
; Transfer types on the registry.
;

TRANSFER_UNKNOWN = 65535
TRANSFER_PIO     = 0
TRANSFER_DMA     = 1
TRANSFER_MMIO    = 2

;
; Lists used to the raw internal form of parameters to and from
; the form shown to users.
;

IoUserList    = ^(IoLocationChoices, 1)
IoRawList     = ^(IoLocationChoices, 2)

SlotUserList  = ^(SlotNumberChoices, 1)
SlotRawList   = ^(SlotNumberChoices, 2)

DmaUserList   = ^(DmaChannelChoices, 1)
DmaRawList    = ^(DmaChannelChoices, 2)

IrqUserList   = ^(IrqNumberChoices, 1)
IrqRawList    = ^(IrqNumberChoices, 2)

RxTxUserList  = ^(RxTxSlotsChoices,1)
RxTxRawList   = ^(RxTxSlotsChoices,2)

StatsUserList = ^(StatsChoices,1)
StatsRawList  = ^(StatsChoices,2)

MpUserList    = ^(MpChoices,1)
MpRawList     = ^(MpChoices,2)

;
; Adapter classification lists.
;

MadgeAdapterOptions  = ^(Options,1)
SlotNumberAdapters   = ^(SlotNumberOnlyOptions,1)
MmioAdapters         = ^(MmioOptions,1)


;
; Help identifiers.
;

MadgeHelpIdMin         = 6000
MadgeHelpIdMax         = 6003
MadgeHelpIdMDGMPISA    = 6001
MadgeHelpIdMDGMPATP    = 6001
MadgeHelpIdMDGMPISAC   = 6001
MadgeHelpIdMDGMPISACP  = 6001
MadgeHelpIdMDGMPPC     = 6001
MadgeHelpIdMDGMPSM16   = 6001
MadgeHelpIdMDGMPPNP    = 6001
MadgeHelpIdMDGMPPCMCIA = 6001
MadgeHelpIdMDGMPEISA   = 6002
MadgeHelpIdMDGMPMCA    = 6002
MadgeHelpIdMDGMPMC32   = 6002
MadgeHelpIdMDGMPPCI    = 6003
MadgeHelpIdMDGMPPCIBM  = 6003

; 
; card ids
;
IDMSMDGMPPCI =   135350; 210B6
IDVMSMDGMPPCI = AdapterCFID

IDMSMDGMPPCIBM =   266422 ; 410B6
IDVMSMDGMPPCIBM = AdapterCFID

IDMSMDGMPEISA =   34612
IDVMSMDGMPEISA = EisaCompressedId

IDMSMDGMPMCA =   45
IDVMSMDGMPMCA = McaPosId

IDMSMDGMPMC32 =   116
IDVMSMDGMPMC32 = McaPosId

[date]

    ; Now is a list which contains { Sec from 1-1-1970, Year, Month, Day, Hour,
    ; Minute, Second }
    Now = {} ? $(!LIBHANDLE) GetSystemDate


;---------------------------------------------------------------------------
; Identify the INF file to NT.
;
; DESCRIPTION:   To verify that this INF deals with the same type of options
;                as we are choosing currently.
;
; INPUT:         None
;
; OUTPUT:        $($R0): STATUS: STATUS_SUCCESSFUL
;                $($R1): Option Type (COMPUTER ...)
;                $($R2): Diskette description
;---------------------------------------------------------------------------

[Identify]

    read-syms Identification

    set Status     = STATUS_SUCCESSFUL
    set Identifier = $(OptionType)
    set Media      = #("Source Media Descriptions", 1, 1)

    return $(Status) $(Identifier) $(Media)

;------------------------------------------------------------------------
; Return the options supported by this INF file.
;
; DESCRIPTION:   To return the option list supported by this INF and the
;                localised text list representing the options.
;
;
; INPUT:         $($0):  Language used. ( ENG | FRN | ... )
;
; OUTPUT:        $($R0): STATUS: STATUS_SUCCESSFUL |
;                                STATUS_NOLANGUAGE
;                                STATUS_FAILED
;                                STATUS_NOTSUPPORTED
;
;                $($R1): Option List
;                $($R2): Option Text List
;------------------------------------------------------------------------

[ReturnOptions]

    set Status         = STATUS_FAILED
    set OptionList     = {}
    set OptionTextList = {}

    ;
    ; Check if the language requested is supported.
    ;

    set LanguageList = ^(LanguagesSupported, 1)

    ifcontains(i) $($0) in $(LanguageList)
    ;
	;
	; Check if the platforms requested is supported
	;

	ifstr(i) $($1) == ""
        ;
	    goto Return_Options
        ;
	endif

	set PlatformList = ^(PlatformsSupported, 1)

	ifcontains(i) $($1) in $(PlatformList)
        ;
	    goto Return_Options
        ;
	else
        ;
	    set Status = STATUS_NOTSUPPORTED

	    goto Finish_ReturnOptions
        ;
	endif
    ;
    else
    ;
        set Status = STATUS_NOLANGUAGE

	goto Finish_ReturnOptions
    ;
    endif

    ;
    ; form a list of all the options and another of the text representing
    ;

Return_Options = +

    set OptionList     = ^(Options$($1), 1)
    set OptionTextList = ^(OptionsText$($1)$($0), 1)
    set Status         = STATUS_SUCCESSFUL

Finish_ReturnOptions = +

    return $(Status) $(OptionList) $(OptionTextList)

;------------------------------------------------------------------------
; InstallOption:
;
;      This section is shelled to by main installation processing
;      or by NCPASHEL.INF during reconfig, removal, update, etc.
;
;
; FUNCTION:  To copy files representing Options
;            To configure the installed option
;            To update the registry for the installed option
;
; INPUT:     $($0):  Language to use
;            $($1):  OptionID to install
;            $($2):  SourceDirectory
;            $($3):  AddCopy  (YES | NO)
;            $($4):  DoCopy   (YES | NO)
;            $($5):  DoConfig (YES | NO)
;
; OUTPUT:    $($R0): STATUS: STATUS_SUCCESSFUL |
;                            STATUS_NOLANGUAGE |
;                            STATUS_USERCANCEL |
;                            STATUS_FAILED
;------------------------------------------------------------------------

[InstallOption]

    StartWait
    
    ;
    ; Un-comment for debugging.
    ;

    ; set !DebugOutputControl = 1

    ;
    ; Set default values.
    ;

    set Status = STATUS_FAILED

    ;
    ; extract parameters
    ;

    set Option   = $($1)
    set SrcDir   = $($2)
    set AddCopy  = $($3)
    set DoCopy   = $($4)
    set DoConfig = $($5)

    Debug-Output "MADGE: STF_CWDIR    = "$(!STF_CWDIR)
    Debug-Output "MADGE: STF_LANGUAGE = "$(!STF_LANGUAGE)
    Debug-Output "MADGE: Option       = "$(Option)
    Debug-Output "MADGE: SrcDir       = "$(SrcDir)
    Debug-Output "MADGE: AddCopy      = "$(AddCopy)
    Debug-Output "MADGE: DoCopy       = "$(DoCopy)
    Debug-Output "MADGE: DoConfig     = "$(DoConfig)

    ;
    ; Check if the language requested is supported
    ;

    set LanguageList = ^(LanguagesSupported, 1)
    
    ifcontains(i) $($0) NOT-IN $(LanguageList)
    ;
	return STATUS_NOLANGUAGE
    ;
    endif

    ;
    ; Define all the constants
    ;

    set-subst LF = "\n"

    read-syms GeneralConstants
    read-syms FileConstants
    read-syms DialogConstants$(!STF_LANGUAGE)

    ifstr(i) $(!NTN_Origination) == "NCPA"
    ;
	set Continue = $(OK)
    ;
    endif

    read-syms FileConstants$(!STF_LANGUAGE)

    SetHelpFile "mdgmpdlg.hlp" $(MadgeHelpIdMin) $(MadgeHelpIdMax)

    detect date

    set-title $(FunctionTitle)

    set To   = Begin
    set From = Begin

    ;
    ; Assume all is well.
    ;

    set CommonStatus = STATUS_SUCCESSFUL

    EndWait

; -----------------------------------------------------------------------
; Set up the operation-mode-based variables and gaily welcome
; the user.  If the "install mode" variable is improperly set,
; assume this is a new installation.
; -----------------------------------------------------------------------

Begin = +

    ;
    ; Until proven otherwise we assume that the adapter has not been
    ; detected by our NetDetect DLL and we have not done any raw->user
    ; mapping of parameter lists.
    ;

    set AdapterDetected     = FALSE
    set MappedRawParameters = FALSE

    ifstr(i) $(!NTN_InstallMode) == deinstall
    ;
    	set StartLabel = Remove_Adapter
    ;
    else-ifstr(i) $(!NTN_InstallMode) == Update
    ;
	set StartLabel = Upgrade_Software
    ;
    else-ifstr(i) $(!NTN_InstallMode) == bind
    ;
    	set StartLabel = Binding_Adapter
    ;
    else-ifstr(i) $(!NTN_InstallMode) == configure
    	set CommonStatus = STATUS_REBOOT
    	set StartLabel = Configure_Adapter

    	;
    	;   You cannot config the software component
    	;

    	ifstr(i) $(ProductKeyName) == $(!NTN_RegBase)
    	    Shell $(UtilityInf),RegistryErrorString,CANNOT_CONFIGURE_SOFTWARE

    	    ifint $($ShellCode) != $(!SHELL_CODE_OK)
    		    goto Shell_Code_Error
            endif

	        set Error = $($R0)
	        set From  = End
	        set To    = End
	        goto Non_Fatal_Info
    	endif
    else
	    set StartLabel           = Install_Adapter
	    set OEM_ABANDON_OPTIONS  = {}
	    set OEM_ABANDON_SOFTWARE = FALSE
	    set OEM_ABANDON_ON       = TRUE
    endif

    set From = Fatal
    set To   = Fatal

    goto $(StartLabel)


; ----------------------------------------------------------------------
; Installation Section
; ----------------------------------------------------------------------

Install_Adapter = +

    ;
    ; First, check whether the same version of the software exists
    ;

    OpenRegKey $(!REG_H_LOCAL) "" $(ProductKeyName) $(MAXIMUM_ALLOWED) KeyProduct

    Ifstr $(KeyProduct) != $(KeyNull)
        ;
	    ;
	    ; Same version already existed in the local machine
	    ; Popup the dialog and ask the user whether he wants to continue
	    ;
	    CloseRegKey $(KeyProduct)

	    ifstr(i) $(!NTN_RegBase) == $(ProductKeyName)
	       ;
	       ; Cannot Install the same software again
	       ;

	       Shell $(UtilityInf), VerExistedDlg, $(ProductSoftwareTitle),+
	           $(ProductVersion)

	       ifint $($ShellCode) != $(!SHELL_CODE_OK)
	           goto Shell_Code_Error
	       endif

	       goto End
	    else
           ;
           ; Make sure the user really wants to add a new adapter.
           ; Don't bother for automatic installation.
           ;

           ifstr(i) $(Option) != "MSMDGMPAUTO"
  	           ;
	           ; Add a new adapter card?
	           ;

   	           Shell $(UtilityInf), CardExistedDlg

	           ifint $($ShellCode) != $(!SHELL_CODE_OK)
	               goto Shell_Code_Error
	           endif

	           ifstr(i) $($R1) != "OK"
	               goto End
	           endif
           endif

	       set OldVersionExisted = $(TRUE)
	    endif
    endif

; -----------------------------------------------------------------------
; Copy the driver and helper files from the distribution disk.
; -----------------------------------------------------------------------

Install_Files = +
    Debug-Output "OEMNADMA.INF: Install Files"
    ifint $(OldVersionExisted) == $(FALSE)
    	ifstr(i) $(!NTN_InstallMode) == "install"
        
	        Shell $(UtilityInf), DoAskSource, $(!STF_CWDDIR), $(!STF_SRCDIR), "YES"

	        ifint $($ShellCode) != $(!SHELL_CODE_OK)
                goto Shell_Code_Error
            
	        else-ifstr(i) $($R0) == STATUS_FAILED
        		shell $(UtilityInf) RegistryErrorString "ASK_SOURCE_FAIL"

	            ifint $($ShellCode) != $(!SHELL_CODE_OK)
	    	        goto Shell_Code_Error
	            endif

	            set Error = $($R0)
	            goto Fatal
    	    else-ifstr(i) $($R0) == STATUS_USERCANCEL
                goto Successful
            endif

	        set SrcDir = $($R1)   ; Referenced in install sections.


	        install "Install-Option"

	        ifstr(i) $(STF_INSTALL_OUTCOME) != STF_SUCCESS
    		    shell $(UtilityInf) RegistryErrorString "UNABLE_COPY_FILE"

	    	    ifint $($ShellCode) != $(!SHELL_CODE_OK)
                    goto Shell_Code_Error
                endif

		        set Error = $($R0)
		        goto Fatal
                
	        endif
            
	    endif
    
    endif

; -----------------------------------------------------------------------
; If the adapter option is MSMDGMPAUTO then we need to perform some adapter
; detection. In addition, we may not have been asked to detect the 
; adapter but NCPA may have already done it for use. If it has then set 
; up the detection variables from the values passed by NCPA.
; -----------------------------------------------------------------------
 
    ifstr(i) $(!STF_NCDETECT) == YES
        ifstr(i) $(!STF_NCOPTION) == $(Option)
            set AdapterDetected = TRUE
            set DetectOption    = $(!STF_NCOPTION)
            set DetectIndex     = $(!STF_NCDETCARD)

            goto Set_Installation_Defaults
        endif
    endif

; -----------------------------------------------------------------------
; Set some defaults that apply to all card types
; -----------------------------------------------------------------------

Set_Installation_Defaults = +
    Debug-Output "OEMNADMA.INF: Set Install Defaults"
    StartWait

    ; 
    ; Set up some defaults that are not affected by automatic detection.
    ;

    set MaxFrameSize  = 4096
    set LAA           = ""
    set RxTxSlots     = *($(RxTxRawList),3)
    set StatsFlag     = *($(StatsRawList),1)
    set SpeedFlag     = 0

    set OldIrqNumber  = $(VALUE_UNKNOWN)
    set OldDmaChannel = $(VALUE_UNKNOWN)
    set OldIoLocation = $(VALUE_UNKNOWN)
    set OldSlotNumber = $(VALUE_UNKNOWN)
    set OldMpFlag     = $(VALUE_UNKNOWN)

    ;
    ; Now set up the options for adapter options.
    ;

    ifcontains(i) $(Option) in $(SlotNumberAdapters)
        set TypeList = {{SLOTNUMBER,SlotList,SlotNumber},+
                        {DMACHANNEL,DmaList,DmaChannel},+
                        {MULTIPROCESSOR,MpList,MpFlag}}
    else
        set TypeList = {{IOLOCATION,IoList,IoLocation},+
                        {DMACHANNEL,DmaList,DmaChannel},+
                        {INTERRUPTNUMBER,IrqList,IrqNumber},+
                        {MULTIPROCESSOR,MpList,MpFlag}}
    endif

    Shell $(ParamInf) Param_BuildTypeLists $(Option) $(TypeList)

    set Status = $($R0)

    ifstr(i) $(Status) != STATUS_SUCCESSFUL
        Debug-Output "OEMNADMA.INF: Param_BuildTypeLists returned "$(Status)
        goto Fatal
    endif

    ;
    ; If the adapter was automatically detected then call the
    ; DLL to find out what the parameters are.
    ;

    ifstr(i) $(AdapterDetected) == TRUE
        Debug-Output "OEMNADMA.INF: Calling Param_QueryCard"

        Shell $(ParamInf) Param_QueryCard $(DetectIndex)

        set Status    = $($R0)
        set ParamList = $($R1)

        ifstr(i) $(Status) != STATUS_SUCCESSFUL
            goto Fatal
        endif
    endif

    ;
    ; And set the defaults. This will be the automatically detected
    ; value if the adapter was detected or the first allowable choice
    ; otherwise. 
    ;
    Debug-Output "OEMNADMA.INF: Calling Param_SetDefaults"

    Shell $(ParamInf) Param_SetDefaults $(ParamList)

    Debug-Output "MADGE: SlotNumber = "$(SlotNumber)
    Debug-Output "MADGE: IoLocation = "$(IoLocation)
    Debug-Output "MADGE: IrqNumber  = "$(IrqNumber)
    Debug-Output "MADGE: DmaChannel = "$(DmaChannel)
    Debug-Output "MADGE: MpFlag     = "$(MpFlag)
    Debug-Output "MADGE: SlotList   = "$(SlotList)
    Debug-Output "MADGE: IoList     = "$(IoList)
    Debug-Output "MADGE: IrqList    = "$(IrqList)
    Debug-Output "MADGE: DmaList    = "$(DmaList)
    Debug-Output "MADGE: MpList     = "$(MpList)

    ;
    ; Note what the hardware detectable values are for later.
    ;

    ifstr(i) $(AdapterDetected) == TRUE
        set OldSlotNumber = $(SlotNumber)
        set OldIoLocation = $(IoLocation)
        set OldIrqNumber  = $(IrqNumber)
        set OldDmaChannel = $(DmaChannel)
        set OldMpFlag     = $(MpFlag)
    endif

    set OldValueTitle = $(OldValueTitleInstall)

    EndWait

    goto Get_Adapter_Options

; -----------------------------------------------------------------------
; Configuration Section
; -----------------------------------------------------------------------

Configure_Adapter = +

    StartWait

    ;
    ; Now set up the options for adapter options.
    ;

    ifcontains(i) $(Option) in $(SlotNumberAdapters)
        set TypeList = {{SLOTNUMBER,SlotList,SlotNumber},+
                        {DMACHANNEL,DmaList,DmaChannel},+
                        {MULTIPROCESSOR,MpList,MpFlag}}
    else
        set TypeList = {{IOLOCATION,IoList,IoLocation},+
                        {DMACHANNEL,DmaList,DmaChannel},+
                        {INTERRUPTNUMBER,IrqList,IrqNumber},+
                        {MULTIPROCESSOR,MpList,MpFlag}}
    endif

    Shell $(ParamInf) Param_BuildTypeLists $(Option) $(TypeList)

    set Status = $($R0)

    ifstr(i) $(Status) != STATUS_SUCCESSFUL
        goto fataldetect
    endif

    ;
    ; And set the defaults. 
    ;

    Shell $(ParamInf) Param_SetDefaults $(ParamList)

    ;
    ; Set up the defaults not done by the help interface the
    ; detection DLL above.
    ;

    set MaxFrameSize = 4096
    set LAA          = ""
    set RxTxSlots    = *($(RxTxRawList),3)
    set StatsFlag    = *($(StatsRawList),1)
    set NoMmioFlag   = 0
    set SpeedFlag    = 0
    set TransferType = $(TRANSFER_UNKNOWN)

    ;
    ; NB !NTN_RegBase, for hardware components, is :
    ;    \SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkCards\0x
    ;

    ;
    ; This next IF is redundant - it will always be NULL
    ;

    ifstr $(KeyProduct) == $(KeyNull)
	    OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_RegBase) $(MAXIMUM_ALLOWED) KeyProduct

	    ifstr $(KeyProduct) == $(KeyNull)
	        set RegistryErrorIndex = CANNOT_FIND_COMPONENT_SERVICE
	        goto Fatal_Registry
	    endif
    endif

    ;
    ; Get the other parameters; they're attached to the service 
    ; parameters key
    ;

    Shell $(UtilityInf) FindService, $(KeyProduct)

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
    	goto Shell_Code_Error
    endif

    ifstr(i) $($R0) != NO_ERROR
    	goto Fatal_Registry
    endif

    set KeyParameters = $($R2)

    ;
    ; We don't need the services key, so close it.
    ;

    CloseRegKey $($R1)

    ifstr $(KeyParameters) == $(KeyNull)
    	set RegistryErrorIndex = CANNOT_FIND_COMPONENT_SERVICE
    	goto Fatal_Registry
    endif

    set OldVersionExisted = $(TRUE)

    ;
    ; Get the old values
    ;

    set ValueName = ""
    set ValueData = ""
    set ValueStr  = ""
    set ValueList = {}

    EnumRegValue $(KeyParameters) ValueList

    ForListDo $(ValueList)
	    set ValueItem = $($)
	    set ValueName = *($(ValueItem),1)
	    set ValueData = *($(ValueItem),4)

	    ifstr(i) $(ValueName) == "InterruptNumber"
	        set IrqNumber = $(ValueData)
	    else-ifstr(i) $(ValueName) == "IoLocation"
	        set IoLocation = $(ValueData)
	    else-ifstr(i) $(ValueName) == "IoBaseAddress"
	        set IoLocation = $(ValueData)
	    else-ifstr(i) $(ValueName) == "DmaChannel"
	        set DmaChannel = $(ValueData)
	    else-ifstr(i) $(ValueName) == "SlotNumber"
	        set SlotNumber = $(ValueData)
	    else-ifstr(i) $(ValueName) == $(McaEisaKeyword)
	        set McaEisaId = $(ValueData)
	    else-ifstr(i) $(ValueName) == "MaxFrameSize"
	        set MaxFrameSize = $(ValueData)
	    else-ifstr(i) $(ValueName) == "NetworkAddress"
	        set LAA = $(ValueData)
        else-ifstr(i) $(ValueName) == "RxTxSlots"
            set RxTxSlots = $(ValueData)
        else-ifstr(i) $(ValueName) == "PromiscuousModeX"
            set StatsFlag = $(ValueData)
        else-ifstr(i) $(ValueName) == "Multiprocessor"
            set MpFlag = $(ValueData)
        else-ifstr(i) $(ValueName) == "NoMmio"
            set NoMmioFlag = $(ValueData)
        else-ifstr(i) $(ValueName) == "Force16"
            set SpeedFlag = 2
        else-ifstr(i) $(ValueName) == "Force4"
            set SpeedFlag = 1
        else-ifstr(i) $(ValueName) == "TransferType"
            set TransferType = $(ValueData)
	    endif
    EndForListDo

    ;
    ; For backward compatibility we translate a DMA channel of 0x8000
    ; into a DMA channel of $(GENERAL_PIO) and a multiprocessor flag of 1.
    ; 

    ifint $(DmaChannel) == 32768
        set DmaChannel = $(GENERAL_PIO)
        set MpFlag     = 1
    endif

    ;
    ; We now need to merge the DmaChannel and NoMmioFlag to produce a
    ; DmaChannel that completely specifies the transfer mode. When
    ; we called the detection DLL to get the defaults DmaChannel will
    ; have been set up properly, including setting unspecific DMA for
    ; EISA, MC and PCI. If we have an MMIO supporting adapter the rule is
    ; as follows. 
    ;
    ; If the NoMmio flag is set then we must not use so MMIO we force
    ; the transfer type to be PIO.
    ;
    ; If the NoMmio flag is not set then we use MMIO.
    ;

    ifcontains(i) $(GENERAL_MMIO) in $(DmaList)
        ifint $(NoMmioFlag) != 0
            set DmaChannel = $(GENERAL_PIO)
        else
            set DmaChannel = $(GENERAL_MMIO)
        endif
    endif

    ;
    ; If the TransferType flag is set to PIO and this adapter supports
    ; PIO then force PIO irrespective of the current value of DmaChannel.
    ;

    ifint $(TransferType) == $(TRANSFER_PIO)
        ifcontains(i) $(GENERAL_PIO) in $(DmaList)
            set DmaChannel = $(GENERAL_PIO)
        endif
    endif

    ;
    ; If the TransferType flag is set to unspecified DMA and this
    ; adapter supports unspecified DMA then force unspecified DMA
    ; irrespective of the current value of DMA channel. This
    ; code is needed for adapters like PCI (BM) where both
    ; PIO and unspecific DMA is supported (EISA and MC adapters
    ; only support unspecific DMA and ISA devices have DmaChannel
    ; set to a specific value.)
    ;

    ifint $(TransferType) == $(TRANSFER_DMA)
        ifcontains(i) $(GENERAL_DMA) in $(DmaList)
            set DmaChannel = $(GENERAL_DMA)
        endif
    endif

    ;
    ; Make a note of the current values.
    ;

    set OldSlotNumber = $(SlotNumber)
    set OldIoLocation = $(IoLocation)
    set OldIrqNumber  = $(IrqNumber)
    set OldDmaChannel = $(DmaChannel)
    set OldMpFlag     = $(MpFlag)
    
    set OldValueTitle = $(OldValueTitleConfigure)

    EndWait

; -----------------------------------------------------------------------
; Let the user set options.
; -----------------------------------------------------------------------

Get_Adapter_Options = +
    Debug-Output "OEMNADMA.INF: Get_Adapter_Options"
    StartWait

    ifstr(i) $(!STF_GUI_UNATTENDED) == "YES"
        ifstr(i) $(!STF_NCDETINFO) == {}
            ifstr(i) $(!AutoNetInterfaceType) != ""
                set BusInterfaceType = $(!AutoNetInterfaceType)
            else
                set BusInterfaceType = 1    ;ISA
            endif
            ifstr(i) $(!AutoNetBusNumber) != ""
                set BusNumber = $(!AutoNetBusNumber)
            else
                set BusNumber = 0
            endif
        else
            ifstr(i) $(!AutoNetInterfaceType) != ""
                set BusInterfaceType = $(!AutoNetInterfaceType)
            else
                set BusInterfaceType = *($(!STF_NCDETINFO),5)
            endif
            ifstr(i) $(!AutoNetBusNumber) != ""
                set BusNumber = $(!AutoNetBusNumber)
            else
                set BusNumber = *($(!STF_NCDETINFO),6)
            endif
        endif
        goto adapterverify
    endif

    ;
    ; Need to be able to tell if the LAA or statistics gathering
    ; flag have changed.
    ;

    set OldLAA       = $(LAA)
    set OldStatsFlag = $(StatsFlag)
    set OldSpeedFlag = $(SpeedFlag)

    ;
    ; Set up the list of adapter ring speeds.
    ;

    set SpeedRawList  = $(SpeedRawList$(Option))
    set SpeedUserList = $(SpeedUserList$(Option))
    
    ;
    ; Map the parameter lists into the form we present to the user.
    ; We only ever do this once.
    ;

    ifstr(i) $(MappedRawParameters) == FALSE
        ifcontains(i) $(Option) not-in $(SlotNumberAdapters)
            set TempList = $(IoList)
            set IoList   = {}
            ForListDo $(TempList)
                set IoList = >($(IoList), *($(IoUserList),~($(IoRawList),$($))))
            EndForListDo

            set TempList = $(IrqList)
            set IrqList  = {}
            ForListDo $(TempList)
                set IrqList = >($(IrqList), *($(IrqUserList),~($(IrqRawList),$($))))
            EndForListDo
        else
            set TempList = $(SlotList)
            set SlotList  = {}
            ForListDo $(TempList)
                set SlotList = >($(SlotList), *($(SlotUserList),~($(SlotRawList),$($))))
            EndForListDo
        endif

        set TempList = $(DmaList)
        set DmaList  = {}
        ForListDo $(TempList)
            set DmaList = >($(DmaList), *($(DmaUserList),~($(DmaRawList),$($))))
        EndForListDo

        set TempList = $(MpList)
        set MpList   = {}
        ForListDo $(TempList)
            set MpList = >($(MpList), *($(MpUserList),~($(MpRawList),$($))))
        EndForListDo

        set MappedRawParameters = TRUE
    endif

    EndWait

Get_Adapter_Options_Restart = +

    ;
    ; We will start here if parameter validation fails.
    ;

    StartWait

    set From = Get_Adapter_Options_Restart

    ;
    ; Map the currently selected values into user from.
    ;

    ifcontains(i) $(Option) not-in $(SlotNumberAdapters)
        set IoLocation    = *($(IoUserList),~($(IoRawList),$(IoLocation)))
        set OldIoLocation = *($(IoUserList),~($(IoRawList),$(OldIoLocation)))
        set IrqNumber     = *($(IrqUserList),~($(IrqRawList),$(IrqNumber)))
        set OldIrqNumber  = *($(IrqUserList),~($(IrqRawList),$(OldIrqNumber)))
    else
        set SlotNumber    = *($(SlotUserList),~($(SlotRawList),$(SlotNumber)))
        set OldSlotNumber = *($(SlotUserList),~($(SlotRawList),$(OldSlotNumber)))
    endif

    set DmaChannel    = *($(DmaUserList),~($(DmaRawList),$(DmaChannel)))
    set OldDmaChannel = *($(DmaUserList),~($(DmaRawList),$(OldDmaChannel)))
    set MpFlag        = *($(MpUserList),~($(MpRawList),$(MpFlag)))
    set OldMpFlag     = *($(MpUserList),~($(MpRawList),$(OldMpFlag)))
    set StatsFlag     = *($(StatsUserList),~($(StatsRawList),$(StatsFlag)))
    set RxTxSlots     = *($(RxTxUserList),~($(RxTxRawList),$(RxTxSlots)))
    set SpeedFlag     = *($(SpeedUserList),~($(SpeedRawList),$(SpeedFlag)))

    ;
    ; Set up the input dialog box text and lists.
    ;

    read-syms FileDependentDlg$(!STF_LANGUAGE)

    ;
    ; Decide which dialog box to use.
    ;

    Debug-Output "MADGE: Option             = "$(Option)
    Debug-Output "MADGE: SlotNumberAdapters = "$(SlotNumberAdapters)

    ifcontains(i) $(Option) in $(SlotNumberAdapters)
	    set DlgTemplate = "MDGEISA"
    else
        set DlgTemplate = "MDGISA"
    endif

    Debug-Output "MADGE: DlgTemplate = "$(DlgTemplate)

    ;
    ; To allow us to re-use the EISA/MCA dialog box for PCI we need
    ; to change Combo8Label.
    ;

    ifstr(i) $(Option) == "MSMDGMPPCI"
        set Combo8Label = $(PciCombo8Label)
    endif

    ;
    ; Let the user press some keys.
    ;

    LoadLibrary "x" $(DialogDllName) MdgDialog

    EndWait

    ui start "InputDlg" $(MdgDialog)

    StartWait

    ifstr(i) $(DLGEVENT) == "EXIT"
	    set CommonStatus = STATUS_USERCANCEL
	    ui pop 1
	    FreeLibrary $(MdgDialog)
	    goto End
    else-ifstr(i) $(DLGEVENT) != "CONTINUE"
	    ui pop 1
	    FreeLibrary $(MdgDialog)
	    goto End
    endif

    ;
    ; Get the values the user selected out of the dialog box.
    ;

    set IrqNumber    = $(Combo1Out)
    set IoLocation   = $(Combo2Out)
    set DmaChannel   = $(Combo3Out)
    set RxTxSlots    = $(Combo4Out)
    set StatsFlag    = $(Combo5Out)
    set MpFlag       = $(Combo7Out)
    set SlotNumber   = $(Combo8Out)
    set SpeedFlag    = $(Combo9Out)

    set MaxFrameSize = *($(EditTextOut), 1)
    set LAA          = *($(EditTextOut), 2)

    ui pop 1
    FreeLibrary $(MdgDialog)

    Debug-Output "MADGE: SlotNumber = "$(SlotNumber)
    Debug-Output "MADGE: IoLocation = "$(IoLocation)
    Debug-Output "MADGE: IrqNumber  = "$(IrqNumber)
    Debug-Output "MADGE: DmaChannel = "$(DmaChannel)
    Debug-Output "MADGE: MpFlag     = "$(MpFlag)
    Debug-Output "MADGE: RxTxSlots  = "$(RxTxSlots)
    Debug-Output "MADGE: StatsFlag  = "$(StatsFlag)

    ;
    ; Convert the values the user has chosen into internal form.
    ;

    ifcontains(i) $(Option) not-in $(SlotNumberAdapters)
        set IoLocation    = *($(IoRawList),~($(IoUserList),$(IoLocation)))
        set OldIoLocation = *($(IoRawList),~($(IoUserList),$(OldIoLocation)))
        set IrqNumber     = *($(IrqRawList),~($(IrqUserList),$(IrqNumber)))
        set OldIrqNumber  = *($(IrqRawList),~($(IrqUserList),$(OldIrqNumber)))
    else
        set SlotNumber    = *($(SlotRawList),~($(SlotUserList),$(SlotNumber)))
        set OldSlotNumber = *($(SlotRawList),~($(SlotUserList),$(OldSlotNumber)))
    endif

    set DmaChannel    = *($(DmaRawList),~($(DmaUserList),$(DmaChannel)))
    set OldDmaChannel = *($(DmaRawList),~($(DmaUserList),$(OldDmaChannel)))
    set MpFlag        = *($(MpRawList),~($(MpUserList),$(MpFlag)))
    set OldMpFlag     = *($(MpRawList),~($(MpUserList),$(OldMpFlag)))
    set StatsFlag     = *($(StatsRawList),~($(StatsUserList),$(StatsFlag)))
    set RxTxSlots     = *($(RxTxRawList),~($(RxTxUserList),$(RxTxSlots)))
    set SpeedFlag     = *($(SpeedRawList),~($(SpeedUserList),$(SpeedFlag)))

    Debug-Output "MADGE: SlotNumber = "$(SlotNumber)
    Debug-Output "MADGE: IoLocation = "$(IoLocation)
    Debug-Output "MADGE: IrqNumber  = "$(IrqNumber)
    Debug-Output "MADGE: DmaChannel = "$(DmaChannel)
    Debug-Output "MADGE: MpFlag     = "$(MpFlag)
    Debug-Output "MADGE: RxTxSlots  = "$(RxTxSlots)
    Debug-Output "MADGE: StatsFlag  = "$(StatsFlag)

    EndWait


; -----------------------------------------------------------------------
; Verify the adapter options.
; -----------------------------------------------------------------------

Adapter_Verify = +

    StartWait

    ;
    ; If the user entered an LAA then validate it.
    ;

    ifstr $(LAA) != ""
        ;
	    ; NB A line of spaces will come through here, and will fail the
	    ;    check - do we want this?
        ;

        LoadLibrary "x" $(DialogDllName) MdgDialog

	    set FLibraryErrCtl = 1

	    LibraryProcedure MdgResult $(MdgDialog) MadgeLAACheck $(LAA)

	    set FLibraryErrCtl = 0

        FreeLibrary $(MdgDialog)

    	ifstr $(MdgResult) != "MADGE_STATUS_SUCCESS"
            ;
            ;
	        ; Illegal LAA supplied in the install dialog
	        ; Display error message and go around again
            ;

	        set Error = $(MdgResult)

            ;
            ; This will go back to Get_Adapter_Options or to end.
            ;

	        goto Non_Fatal 
	    endif
    endif

    ifint $(MaxFrameSize) > 17839
        ;
        ; 17839 is the maximum frame size at 16Mbps, while at 4Mbps it is 4472.
        ; Unfortunately, we can't tell here what the ring speed is, so guess at
        ; 16Mbps, which is the most sensible.
        ;

	    set MaxFrameSize = 17839
	    set Error        = $(TRIMMED_MFS)
	    set From         = Update_Registry

	    goto Non_Fatal_Info
    endif


    ifstr(i) $(!STF_NCDETINFO) == {}
        Shell $(UtilityInf), GetBusTypeDialog, $(ProductHardware$(Option)Description) $(BusNumber)

        ifint $($ShellCode) != $(!SHELL_CODE_OK)
    	    goto Shell_Code_Error
        endif
        
        set BusInterfaceType = $($R1)
        set BusNumber = $($R2)
    else
        set BusInterfaceType = *($(!STF_NCDETINFO),5)
        set BusNumber = *($(!STF_NCDETINFO),6)
    endif

adapterverify = +

    Debug-Output "At adapterverify"
    Shell "" DebugConfiguration "after running dialog"

    ;===================================================
    ;  Netcard Detection logic
    ;
    ;   If this is a detected card, attempt to validate the options
    ;
    Ifstr(i) $(AdapterDetected) != TRUE
        Goto Update_Registry
    Endif

    Debug-Output "OEMNADMA.INF: Calling Param_VerifyCard"

    Shell $(ParamInf) Param_VerifyCard $(!STF_NCDETCARD)
    Ifstr(i) $($R0) == STATUS_SUCCESSFUL
        Debug-Output "OEMNADMA.INF: Param_VerifyCard succeeded"
        Goto Update_Registry
    Endif
    ;
    ;   Give the user a chance to retry or force the options given.
    ;
    Set from = Get_Adapter_Options
    Set to = Update_Registry
    Shell $(UtilityInf),RegistryErrorString,VERIFY_WARNING
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "ShellCode error: cannot get an error string."
        goto ShellCodeError
    endif
    set Error = $($R0)
    Goto Warning
    ;
    ;  End Netcard Detection logic
    ;===================================================




    EndWait

; -----------------------------------------------------------------------
; We have checked the options so add the software parameters to the
; registry.
; -----------------------------------------------------------------------

Update_Registry = +

    ;
    ; If installing, go create the necessary keys;
    ; if configuring, they're already open.
    ;

    ifint $(OldVersionExisted) == $(TRUE)
	    ifstr(i) $(!NTN_InstallMode) == configure
	        goto Write_Parameters
	    endif
    endif

    StartWait

    ;
    ; Add Software Component.
    ;

    ifint $(OldVersionExisted) == $(FALSE)
	    Shell $(UtilityInf), AddSoftwareComponent, $(Manufacturer), +
	        $(ProductSoftwareName), +
	        $(ProductSoftwareName), +
	        $(ProductSoftwareTitle), $(STF_CONTEXTINFNAME), +
	        $(ProductSoftwareImagePath), "kernel", "NDIS", {}, "",+
	        $(MadgeEventLogFile)

	    Set OEM_ABANDON_SOFTWARE = TRUE

	    ifint $($ShellCode) != $(!SHELL_CODE_OK)
	        goto Shell_Code_Error
	    endif

	    ;
	    ; At this point:
	    ;     $R1 contains the product version key handle;
	    ;     $R2 contains the NetRules subkey handle;
	    ;     $R3 contains the new Services key handle; and
	    ;     $R4 contains the Parameters key
	    ;     $R5 contains the Linkage Key
	    ;

	    set RegistryErrorIndex = $($R0)
	    set KeyProduct         = $($R1)
	    Set SoftNetRulesKey    = $($R2)
	    CloseRegKey $($R3)
	    CloseRegKey $($R4)
	    CloseRegKey $($R5)

	    ifstr(i) $(RegistryErrorIndex) != NO_ERROR
            ;
	        CloseRegKey $(KeyProduct)
	        CloseRegKey $(SoftNetRulesKey)
	        goto Fatal_Registry
            ;
	    endif

	    set NewValueList = {{SoftwareType,$(NoTitle),$(!REG_VT_SZ),$(SoftwareType)},+
			       {MajorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMajorVersion)},+
			       {MinorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMinorVersion)},+
			       {Title,$(NoTitle),$(!REG_VT_SZ),$(ProductSoftwareTitle)},+
			       {Description,$(NoTitle),$(!REG_VT_SZ),$(ProductSoftwareDescription)},+
			       {PathName,$(NoTitle),$(!REG_VT_SZ),$(!STF_CWDDIR)},+
			       {ServiceName,$(NoTitle),$(!REG_VT_SZ),$(ProductSoftwareName)},+
			       {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(Now),1)}}

	    Shell $(UtilityInf), AddValueList, $(KeyProduct), $(NewValueList)

	    ifint $($ShellCode) != $(!SHELL_CODE_OK)
	        goto Shell_Code_Error
	    endif

	    set RegistryErrorIndex = $($R0)

	    ifstr(i) $(RegistryErrorIndex) != NO_ERROR
	        CloseRegKey $(KeyProduct)
	        CloseRegKey $(SoftNetRulesKey)

	        goto Fatal_Registry
	    endif

	    set NewValueList = {{type,$(NoTitle),$(!REG_VT_SZ),$(NetRuleSoftwareType)},+
			        {use,$(NoTitle),$(!REG_VT_SZ),$(NetRuleSoftwareUse)}, +
			        {bindform,$(NoTitle),$(!REG_VT_SZ),$(NetRuleSoftwareBindForm)}, +
			        {class,$(NoTitle),$(!REG_VT_MULTI_SZ),$(NetRuleSoftwareClass)}, +
			        {bindable,$(NoTitle),$(!REG_VT_MULTI_SZ),$(NetRuleSoftwareBindable)}, +
			        {InfOption,$(NoTitle),$(!REG_VT_SZ),$(Option)}, +
			        {Infname ,$(NoTitle),$(!REG_VT_SZ),$(STF_CONTEXTINFNAME)} }

	    Shell $(UtilityInf), AddValueList, $(SoftNetRulesKey), $(NewValueList)

	    ifint $($ShellCode) != $(!SHELL_CODE_OK)
	        goto Shell_Code_Error
	    endif

	    set RegistryErrorIndex = $($R0)

	    CloseRegKey $(KeyProduct)
	    CloseRegKey $(SoftNetRulesKey)

	    ifstr(i) $(RegistryErrorIndex) != NO_ERROR
	        goto Fatal_Registry
	    endif
    endif

    ;
    ; Create the HARDWARE\Netcard region and its corresponding service
    ;

    Shell $(UtilityInf), AddHardwareComponent, $(ProductHardwareName),$(STF_CONTEXTINFNAME),$(ProductKeyName)

    ifint $($R4) != -1
    	Set OEM_ABANDON_OPTIONS = >($(OEM_ABANDON_OPTIONS), $(!NTN_SoftwareBase)"\Microsoft\Windows NT\CurrentVersion\NetworkCards\"$($R4))
    endif
		
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
	    goto Shell_Code_Error
    endif

    set RegistryErrorIndex = $($R0)

    ifstr(i) $(RegistryErrorIndex) != NO_ERROR
	    CloseRegKey $($R1)
	    CloseRegKey $($R2)
	    CloseRegKey $($R3)
	    goto Fatal_Registry
    endif

    ;
    ; At this point:
    ;     $R1  Registry key variable for HARDWARE\Netcard\(n)
    ;     $R2  Registry key variable for HARDWARE\Netcard\(n)\\NetRules
    ;     $R3  Registry key handle for <service>\Parameters key
    ;     $R4  Adapter number assigned to adapter
    ;     $R5  Service name generated by combining svc name with adapter number
    ;

    set KeyParameters   = $($R3)
    set KeyAdapterRules = $($R2)
    set AdapterNumber   = $($R4)

    set NewValueList = {{Manufacturer,$(NoTitle),$(!REG_VT_SZ),$(Manufacturer)},+
		       {Title,$(NoTitle),$(!REG_VT_SZ),"["$($R4)"] "$(ProductHardware$(Option)Title)},+
		       {Description,$(NoTitle),$(!REG_VT_SZ),$(ProductHardware$(Option)Description)},+
		       {ProductName,$(NoTitle),$(!REG_VT_SZ),$(ProductHardwareName)},+
		       {ServiceName,$(NoTitle),$(!REG_VT_SZ),$($R5)},+
               {OperationsSupport,$(NoTitle),$(!REG_VT_DWORD),$(ProductOpSupport)},+
		       {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(Now),1)}}

    Shell $(UtilityInf), AddValueList, $($R1), $(NewValueList)

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
    	goto Shell_Code_Error
    endif

    CloseRegKey $($R1)

    set TempProdName = """"$(ProductHardwareName)$(AdapterNumber)""""
    set TempBindForm = $(TempProdName)$(NetRuleHardwareBindForm)

    set NewValueList = {{type,$(NoTitle),$(!REG_VT_SZ),$(NetRuleHardwareType)},+
			{bindform,$(NoTitle),$(!REG_VT_SZ),$(TempBindForm)}, +
			{class,$(NoTitle),$(!REG_VT_MULTI_SZ),$(NetRuleHardwareClass)}, +
			{InfOption,$(NoTitle),$(!REG_VT_SZ),$(Option)}, +
			{Infname ,$(NoTitle),$(!REG_VT_SZ),$(STF_CONTEXTINFNAME)}}

    Shell $(UtilityInf), AddValueList, $(KeyAdapterRules), $(NewValueList)

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
    	goto Shell_Code_Error
    endif

    set RegistryErrorIndex = $($R0)

    ifstr(i) $(RegistryErrorIndex) != NO_ERROR
	    CloseRegKey $(KeyParameters)
	    CloseRegKey $(KeyAdapterRules)
	    goto Fatal_Registry
    endif

    CloseRegKey $(KeyAdapterRules)

    EndWait

; ----------------------------------------------------------------------
; Write the adapter parameters into the registry.
; ----------------------------------------------------------------------

;
; REQUIRED: $(KeyParameters) contains service Parameters key handle.
;

Write_Parameters = +

    StartWait

    ;
    ; It would appear that when installing a PCMCIA adapter
    ; one should give the bus type of the PCMCIA controller
    ; rather than PCMCIA itself.
    ;

    ifstr(i) $(Option) == "MSMDGMPPCMCIA"
        set BusInterfaceType = 1
    endif

    ;
    ; We need to examine DmaChannel to decide on how to set DmaChannel
    ; and NoMmio. We use a very simple test - if DmaChannel is not
    ; $(GENERAL_MMIO) then we set NoMmio, otherwise we clear it. We
    ; probably should abandon this flag since we can convey the same
    ; information in a more consistent form in the TransferType
    ; parameter below. We'll keep it for backwards compatability.
    ;

    ifint $(DmaChannel) == $(GENERAL_MMIO)
        set NoMmioFlag = 0
    else
        set NoMmioFlag = 1
    endif

    ;
    ; Work out the general transfer type.
    ;

    ifint $(DmaChannel) == $(GENERAL_PIO)
        set TransferType = $(TRANSFER_PIO)
    else-ifint $(DmaChannel) == $(GENERAL_MMIO)
        set TransferType = $(TRANSFER_MMIO)
    else
        set TransferType = $(TRANSFER_DMA)
    endif

    ;
    ; Derive the adapter type.
    ;

    set AdapterTypeFlag = $(AdapterTypeFlag$(Option))

    ;
    ; Add the rest of the parameters to the Services adapter area.
    ;

    ifcontains(i) $(Option) not-in $(SlotNumberAdapters)
    	set NewValueList = {{InterruptNumber,$(NoTitle),$(!REG_VT_DWORD),$(IrqNumber)},+
			{BusType,        $(NoTitle),$(!REG_VT_DWORD),$(BusInterfaceType)},+
			{BusNumber,      $(NoTitle),$(!REG_VT_DWORD),$(BusNumber)},+
			{MediaType,      $(NoTitle),$(!REG_VT_DWORD),2},+
			{IoLocation,     $(NoTitle),$(!REG_VT_DWORD),$(IoLocation)},+
			{IoBaseAddress,  $(NoTitle),$(!REG_VT_DWORD),$(IoLocation)},+
			{DmaChannel,     $(NoTitle),$(!REG_VT_DWORD),$(DmaChannel)},+
			{NoMmio,         $(NoTitle),$(!REG_VT_DWORD),$(NoMmioFlag)},+
			{TransferType,   $(NoTitle),$(!REG_VT_DWORD),$(TransferType)},+
                        {RxTxSlots,      $(NoTitle),$(!REG_VT_DWORD),$(RxTxSlots)},+
                        {Multiprocessor, $(NoTitle),$(!REG_VT_DWORD),$(MpFlag)},+
			{MaxFrameSize,   $(NoTitle),$(!REG_VT_DWORD),$(MaxFrameSize)},+
                        {AdapterType,    $(NoTitle),$(!REG_VT_DWORD),$(AdapterTypeFlag)}}
    else
    	set NewValueList = {+
			{BusType,        $(NoTitle),$(!REG_VT_DWORD),$(BusInterfaceType)},+
			{BusNumber,      $(NoTitle),$(!REG_VT_DWORD),$(BusNumber)},+
			{MediaType,      $(NoTitle),$(!REG_VT_DWORD),2},+
			{SlotNumber,     $(NoTitle),$(!REG_VT_DWORD),$(SlotNumber)},+
			{NoMmio,         $(NoTitle),$(!REG_VT_DWORD),$(NoMmioFlag)},+
			{TransferType,   $(NoTitle),$(!REG_VT_DWORD),$(TransferType)},+
                        {RxTxSlots,      $(NoTitle),$(!REG_VT_DWORD),$(RxTxSlots)},+
                        {Multiprocessor, $(NoTitle),$(!REG_VT_DWORD),$(MpFlag)},+
			{MaxFrameSize,   $(NoTitle),$(!REG_VT_DWORD),$(MaxFrameSize)},+
                        {AdapterType,    $(NoTitle),$(!REG_VT_DWORD),$(AdapterTypeFlag)}}
    endif

    ;
    ; Add specific card ID 
    ;

    ifstr(i) $(ID$(Option)) != ""
    	set NewValueList = >($(NewValueList),+
			     {$(IDV$(Option)), $(NoTitle), $(!REG_VT_DWORD), $(ID$(Option))})
    endif
    
    ;
    ; Add the LAA if there is one.
    ;

    ifstr $(LAA) != ""
    	set NewValueList = >($(NewValueList),+
			     {NetworkAddress, $(NoTitle), $(!REG_VT_SZ), $(LAA)})
    endif

    ;
    ; Enable promiscuous mode if required.
    ;

    ifstr $(StatsFlag) == "1"
    	set NewValueList = >($(NewValueList),+
			     {PromiscuousModeX, $(NoTitle), $(!REG_VT_DWORD), $(StatsFlag)})
    endif

    ;
    ; Enable Force4 mode if required.
    ;

    ifstr $(SpeedFlag) == "1"
    	set NewValueList = >($(NewValueList),+
			     {Force4, $(NoTitle), $(!REG_VT_DWORD), 1})
    endif

    ;
    ; Enable Force16 mode if required.
    ;

    ifstr $(SpeedFlag) == "2"
    	set NewValueList = >($(NewValueList),+
			     {Force16, $(NoTitle), $(!REG_VT_DWORD), 1})
    endif

    ;
    ; If this is a PCMCIA adapter we need to a PCMCIA flag.
    ;

    ifstr(i) $(Option) == "MSMDGMPPCMCIA"
    	set NewValueList = >($(NewValueList),+
			     {Pcmcia, $(NoTitle), $(!REG_VT_DWORD), 1})
    endif

      
    ;
    ; And add the parameters to the registry.
    ;

    Shell  $(UtilityInf), AddValueList, $(KeyParameters), $(NewValueList)

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
    	goto Shell_Code_Error
    endif

    set RegistryErrorIndex = $($R0)

    Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
	    CloseRegKey $(KeyParameters)
	    goto Fatal_Registry
    endif

    ifstr(i) $(!STF_GUI_UNATTENDED) == "YES"
        Shell $(UtilityInf),AddDefaultNetCardParameters,$(KeyParameters)
    endif

    ;
    ; If the old LAA has been cleared then so delete the key 
    ; from registry.
    ;

    ifstr $(OldLAA) != ""
	    ifstr $(LAA) == ""
	        DeleteRegValue $(KeyParameters) NetworkAddress
	    endif
    endif

    ;
    ; If Force4 mode has been disabled then delete the key.
    ;

    ifstr $(OldSpeedFlag) == "1"
	    ifstr $(SpeedFlag) != "1"
	        DeleteRegValue $(KeyParameters) Force4
	    endif
    endif

    ;
    ; If Force16 mode has been disabled then delete the key.
    ;

    ifstr $(OldSpeedFlag) == "2"
	    ifstr $(SpeedFlag) != "2"
	        DeleteRegValue $(KeyParameters) Force16
	    endif
    endif

    ;
    ; If promiscuous mode has been disabled then delete the key.
    ;

    ifstr $(OldStatsFlag) != "0"
	    ifstr $(StatsFlag) == "0"
	        DeleteRegValue $(KeyParameters) PromiscuousModeX
	    endif
    endif

    CloseRegKey $(KeyParameters)

    EndWait

    goto Successful

; -----------------------------------------------------------------------
; Binding section
; -----------------------------------------------------------------------

Binding_Adapter =+

    set Error = "Binding: Sorry, not yet implemented."

    goto Fatal

; -----------------------------------------------------------------------
; Removal section
; -----------------------------------------------------------------------

Remove_Adapter = +

    StartWait

    ;
    ; Remove the software component if required.
    ;

    ifstr(i) $(ProductKeyName) == $(!NTN_RegBase)
	    Shell $(UtilityInf), RemoveSoftwareComponent, $(Manufacturer), +
	        $(ProductSoftwareName)

	    ifint $($ShellCode) != $(!SHELL_CODE_OK)
	        goto Shell_Code_Error
	    endif

	    set RegistryErrorIndex = $($R0)

	    ifstr(i) $(RegistryErrorIndex) != NO_ERROR
	        goto Fatal_Registry
	    endif

    ;
    ; Or, the hardware component.
    ;
    else
	    Shell $(UtilityInf), RemoveHardwareComponent, $(Manufacturer), +
	        $(ProductSoftwareName), $(!NTN_RegBase)     

	    ifint $($ShellCode) != $(!SHELL_CODE_OK)
	        goto Shell_Code_Error
	    endif

	    set RegistryErrorIndex = $($R0)

	    ifstr(i) $(RegistryErrorIndex) != NO_ERROR
	        goto Fatal_Registry
	    endif
    endif

    EndWait

    goto End

; -----------------------------------------------------------------------
; Upgrade Software section.
; -----------------------------------------------------------------------

Upgrade_Software = +

    StartWait

    ;
    ; First determine whether we want to do upgrade or update for software
    ; or hardware component. Then we will determine whether the Mode is
    ; update or upgrade.
    ;

    ifstr(i) $(ProductKeyName) == $(!NTN_RegBase)
        ;
        ;
	    ; Upgrade software component
	    ;
	    ; see whether the same version exist or not
	    ;

	    OpenRegKey $(!REG_H_LOCAL) "" $(ProductKeyName) $(MAXIMUM_ALLOWED) KeyProduct

	    ifstr $(KeyProduct) != $(KeyNull)
	        GetRegValue $(KeyProduct),"MajorVersion", VersionInfo
	        set Version = *($(VersionInfo), 4)

	        ;
	        ; Update the binaries
	        ;

	        shell $(UtilityInf) GetInfFileNameFromRegistry $(KeyProduct)

	        ifint $($ShellCode) != $(!SHELL_CODE_OK)
    		    goto Shell_Code_Error
            endif

	        set !UG_Filename = $($R0)

	        ifstr(i) $(!UG_Filename) != ""
        	    install "Install-Update"

		        ifstr(i) $(STF_INSTALL_OUTCOME) != STF_SUCCESS
                    goto Fatal
                endif
	        endif

	        CloseRegKey $(KeyProduct)
	        OpenRegKey $(!REG_H_LOCAL) "" $(ProductKeyName) $(MAXIMUM_ALLOWED) KeyProduct

            ;
	        ; Upgrade the version number
	        ;

	        SetRegValue $(KeyProduct) {MajorVersion,$(NoTitle),$(!REG_VT_SZ),$(ProductMajorVersion)}
	        SetRegValue $(KeyProduct) {MinorVersion,$(NoTitle),$(!REG_VT_SZ),$(ProductMinorVersion)}

	        ifint $(Version) != $(ProductMajorVersion)
               ;
	           ;
	           ; If the major version number is not the same,
	           ; it is major upgrade. So let Upgrade the product
	           ;
	           ;
	           ; make other upgrade change if necessary
	           ;
               ;
            endif

	        CloseRegKey $(KeyProduct)
	    else
            ;
	        ;
	        ; Cannot Open software key, goto ERROR
	        ;

	        goto Fatal_Registry
            ;
	    endif

        ;
        ; Enumerate all netcards installed of this type and update them
        ;
        set iSearch = 1
nextnetcard = +
        Shell $(UtilityInf), FindNextNetworkCard, $(ProductHardwareName), $(iSearch)
        set KeyNetcard = $($R0)
        set iSearch = $($R1)
        Debug-Output "OemNadEp.Inf: FindNextNetworkCard "$(KeyNetcard)","$(iSearch)
        Ifstr $(KeyNetcard) != $(KeyNull)
            Debug-Output "OemNadEp.Inf: Setting OperationsSupport value"
            SetRegValue $(KeyNetcard) {OperationsSupport,$(NoTitle),$(!REG_VT_DWORD),$(ProductOpSupport)}
            CloseRegKey $(KeyNetcard)

            goto nextnetcard
        Endif

    else
        ;
        ; We cannot upgrade the hardware component.
        ;

        set Error          = ""
        set OEM_ABANDON_ON = FALSE

        goto Not_Supported
    endif
     
    EndWait
										
    goto End

; -----------------------------------------------------------------------
; Escape hatches
; -----------------------------------------------------------------------

Successful = +

    goto End

; -----------------------------------------------------------------------

Abandon = +

    ForListDo $(OEM_ABANDON_OPTIONS)
    ;
	Shell $(UtilityInf), RemoveHardwareComponent, $(Manufacturer), +
	    $(ProductSoftwareName), $($)        

	ifint $($ShellCode) != $(!SHELL_CODE_OK)
        ;
	    goto Shell_Code_Error
        ;
	endif

	set RegistryErrorIndex = $($R0)

	Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
        ;
	    goto Fatal_Registry
        ;
	endif
    ;
    EndForListDo

    ifstr(i) $(OEM_ABANDON_SOFTWARE) == TRUE
    ;
        ;
	; Remove Software Component
        ;

	Shell $(UtilityInf), RemoveSoftwareComponent, $(Manufacturer), +
	    $(ProductSoftwareName), FALSE

	ifint $($ShellCode) != $(!SHELL_CODE_OK)
        ;
	    goto Shell_Code_Error
        ;
	endif

	set RegistryErrorIndex = $($R0)

	ifstr(i) $(RegistryErrorIndex) != NO_ERROR
        ;
	    goto Fatal_Registry
        ;
	endif
    ;
    endif

    goto End

; -----------------------------------------------------------------------

Warning = +

    EndWait

    Shell $(SubroutineInf) SetupMessage, $(!STF_LANGUAGE), "WARNING", $(Error)

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
    ;
	goto Shell_Code_Error
    ;
    endif

    ifstr(i) $($R1) == "OK"
    ;
	goto $(To)
    ;
    else-ifstr(i) $($R1) == "CANCEL"
    ;
	goto $(From)
    ;
    endif

    goto End

; -----------------------------------------------------------------------

Non_Fatal_Info = +

    set Severity     = STATUS
    set CommonStatus = STATUS_USERCANCEL
    goto Non_Fatal_Msg

; -----------------------------------------------------------------------

Non_Fatal = +

    set  Severity = NONFATAL
    goto Non_Fatal_Msg

; -----------------------------------------------------------------------

Non_Fatal_Msg = +

    EndWait

    ifstr(i) $(Error) == ""
    ;
	set Severity = NONFATAL

	Shell $(UtilityInf) RegistryErrorString "SETUP_FAIL"

	ifint $($ShellCode) != $(!SHELL_CODE_OK)
        ;
	    goto Shell_Code_Error
        ;
	endif

	set Error = $($R0)
    ;
    endif

    Shell $(SubroutineInf) SetupMessage, $(!STF_LANGUAGE), "NONFATAL", $(Error)

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
    ;
	goto Shell_Code_Error
    ;
    endif

    ifstr(i) $($R1) == "OK"
    ;
	goto $(From)
    ;
    endif

    goto End

; -----------------------------------------------------------------------

Fatal_Registry = +

    Shell $(UtilityInf) RegistryErrorString $(RegistryErrorIndex)

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
    ;
	goto Shell_Code_Error
    ;
    endif

    set Error = $($R0)

    goto Fatal

; -----------------------------------------------------------------------

;
;  Netcard detection failure
;
fataldetect = +
    Debug-Output "At fataldetect"
    Shell $(UtilityInf),RegistryErrorString,CANNOT_DETECT
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "ShellCode error: cannot get an error string."
        goto ShellCodeError
    endif
    set Error = $($R0)
    Goto fatal

; -----------------------------------------------------------------------

Fatal = +

    EndWait

    ifstr(i) $(Error) == ""
    ;
	Shell $(UtilityInf) RegistryErrorString "SETUP_FAIL"

	ifint $($ShellCode) != $(!SHELL_CODE_OK)
        ;
	    goto Shell_Code_Error
        ;
	endif

	set Error = $($R0)
    ;
    endif

    Shell $(SubroutineInf) SetupMessage, $(!STF_LANGUAGE), "FATAL", $(Error)

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
    ;
	goto Shell_Code_Error
    ;
    endif

    goto Set_Failed

; -----------------------------------------------------------------------

Not_Supported = +

    EndWait

    ifstr(i) $(Error) == ""
    ;
	Shell $(UtilityInf) RegistryErrorString "OPERATION_UNIMPLEMENTED"

	ifint $($ShellCode) != $(!SHELL_CODE_OK)
        ;
	    goto Shell_Code_Error
        ;
	endif

	set Error = $($R0)
    ;
    endif

    Shell $(SubroutineInf) SetupMessage, $(!STF_LANGUAGE), "FATAL", $(Error)

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
    ;
	goto Shell_Code_Error
    ;
    endif

    goto End

; -----------------------------------------------------------------------

Shell_Code_Error = +

    EndWait

    set DlgType      = "MessageBox"
    set STF_MB_TITLE = $(ShellCodeErrorTitle)
    set STF_MB_TEXT  = $(ShellCodeErrorText)
    set STF_MB_TYPE  = 1
    set STF_MB_ICON  = 3
    set STF_MB_DEF   = 1
    ui start "Error Message"
    goto Set_Failed

; -----------------------------------------------------------------------

Set_Failed = +

    set CommonStatus = STATUS_FAILED

    ;
    ; if OEM_ABANDON_ON == TRUE, then remove the registry entries
    ;

    ifstr(i) $(OEM_ABANDON_ON) == TRUE
    ;
	set OEM_ABANDON_ON = FALSE
	goto Abandon
    ;
    endif

    goto End

; -----------------------------------------------------------------------

End = +

    goto Term

; -----------------------------------------------------------------------

Term = +

    Return $(CommonStatus)

; -----------------------------------------------------------------------
; Install sections
; -----------------------------------------------------------------------

[Install-Update]

   set STF_VITAL        = ""
   set STF_OVERWRITE    = "VERIFYSOURCEOLDER"

   AddSectionFilesToCopyList Files-Helper $(SrcDir) $(!STF_WINDOWSSYSPATH)
   AddSectionFilesToCopyList Files-Driver $(SrcDir) $(!STF_WINDOWSSYSPATH)\drivers
   exit

[Install-Option]

    set STF_VITAL        = ""

    AddSectionFilesToCopyList Files-Helper $(SrcDir) $(!STF_WINDOWSSYSPATH)
    AddSectionFilesToCopyList Files-Driver $(SrcDir) $(!STF_WINDOWSSYSPATH)\drivers
    ifstr(i) $(DoCopy) == "YES"
        set !STF_NCPA_FLUSH_COPYLIST = TRUE
        CopyFilesInCopyList
    else
        LibraryProcedure STATUS,$(!NCPA_HANDLE), CopySingleFile $(!STF_HWND) $(SrcDir)\mdgmpdlg.DLL $(!STF_WINDOWSSYSPATH)\mdgmpdlg.DLL
        LibraryProcedure STATUS,$(!NCPA_HANDLE), CopySingleFile $(!STF_HWND) $(SrcDir)\mdgmpdlg.HLP $(!STF_WINDOWSSYSPATH)\mdgmpdlg.HLP
    Endif
    exit


; ******** End of file OEMSETUP.INF *****************************************

