/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/


/*
 * AUTOMATICALLY UPDATED OR GENERATED BY SGI: DO NOT EDIT
 * IF YOU MUST MODIFY THIS FILE, PLEASE CONTACT ptar@sgi.com 415-390-1483
 */

#include "precomp.h"
#pragma hdrstop

#define const           // Don't bother with const

#include "glsbmsg.h"
#include "glsbmsgh.h"

#include "glsrvu.h"

VOID * FASTCALL
sbs_glAddSwapHintRectWIN ( __GLcontext *gc, IN GLMSG_ADDSWAPHINTRECTWIN *pMsg )
{
    (*gc->srvDispatchTable.AddSwapHintRectWIN)(
        pMsg->xs, pMsg->ys, pMsg->xe, pMsg->ye);

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glDrawPolyArray ( __GLcontext *gc, IN GLMSG_DRAWPOLYARRAY *pMsg )
{
    (*gc->srvDispatchTable.DrawPolyArray)( pMsg->pa0 );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glColor4fv ( __GLcontext *gc, IN GLMSG_COLOR4FV *pMsg )
{
    (*gc->srvDispatchTable.Color4fv)( pMsg->v );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glEdgeFlag ( __GLcontext *gc, IN GLMSG_EDGEFLAG *pMsg )
{
    (*gc->srvDispatchTable.EdgeFlag)( pMsg->flag );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glIndexf ( __GLcontext *gc, IN GLMSG_INDEXF *pMsg )
{
    (*gc->srvDispatchTable.Indexf)( pMsg->c );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glNormal3fv ( __GLcontext *gc, IN GLMSG_NORMAL3FV *pMsg )
{
    (*gc->srvDispatchTable.Normal3fv)( pMsg->v );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glRasterPos4fv ( __GLcontext *gc, IN GLMSG_RASTERPOS4FV *pMsg )
{
    (*gc->srvDispatchTable.RasterPos4fv)( pMsg->v );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glTexCoord4fv ( __GLcontext *gc, IN GLMSG_TEXCOORD4FV *pMsg )
{
    (*gc->srvDispatchTable.TexCoord4fv)( pMsg->v );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glClipPlane ( __GLcontext *gc, IN GLMSG_CLIPPLANE *pMsg )
{
    (*gc->srvDispatchTable.ClipPlane)( pMsg->plane, pMsg->equation );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glColorMaterial ( __GLcontext *gc, IN GLMSG_COLORMATERIAL *pMsg )
{
    (*gc->srvDispatchTable.ColorMaterial)( pMsg->face, pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glCullFace ( __GLcontext *gc, IN GLMSG_CULLFACE *pMsg )
{
    (*gc->srvDispatchTable.CullFace)( pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glFogfv ( __GLcontext *gc, IN GLMSG_FOGFV *pMsg )
{
    (*gc->srvDispatchTable.Fogfv)( pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glFrontFace ( __GLcontext *gc, IN GLMSG_FRONTFACE *pMsg )
{
    (*gc->srvDispatchTable.FrontFace)( pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glHint ( __GLcontext *gc, IN GLMSG_HINT *pMsg )
{
    (*gc->srvDispatchTable.Hint)( pMsg->target, pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glLightfv ( __GLcontext *gc, IN GLMSG_LIGHTFV *pMsg )
{
    (*gc->srvDispatchTable.Lightfv)( pMsg->light, pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glLightModelfv ( __GLcontext *gc, IN GLMSG_LIGHTMODELFV *pMsg )
{
    (*gc->srvDispatchTable.LightModelfv)( pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glLineStipple ( __GLcontext *gc, IN GLMSG_LINESTIPPLE *pMsg )
{
    (*gc->srvDispatchTable.LineStipple)( pMsg->factor, pMsg->pattern );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glLineWidth ( __GLcontext *gc, IN GLMSG_LINEWIDTH *pMsg )
{
    (*gc->srvDispatchTable.LineWidth)( pMsg->width );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glMaterialfv ( __GLcontext *gc, IN GLMSG_MATERIALFV *pMsg )
{
    (*gc->srvDispatchTable.Materialfv)( pMsg->face, pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPointSize ( __GLcontext *gc, IN GLMSG_POINTSIZE *pMsg )
{
    (*gc->srvDispatchTable.PointSize)( pMsg->size );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPolygonMode ( __GLcontext *gc, IN GLMSG_POLYGONMODE *pMsg )
{
    (*gc->srvDispatchTable.PolygonMode)( pMsg->face, pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glScissor ( __GLcontext *gc, IN GLMSG_SCISSOR *pMsg )
{
    (*gc->srvDispatchTable.Scissor)( pMsg->x, pMsg->y, pMsg->width, pMsg->height );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glShadeModel ( __GLcontext *gc, IN GLMSG_SHADEMODEL *pMsg )
{
    (*gc->srvDispatchTable.ShadeModel)( pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glTexParameterfv ( __GLcontext *gc, IN GLMSG_TEXPARAMETERFV *pMsg )
{
    (*gc->srvDispatchTable.TexParameterfv)( pMsg->target, pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glTexParameteriv ( __GLcontext *gc, IN GLMSG_TEXPARAMETERIV *pMsg )
{
    (*gc->srvDispatchTable.TexParameteriv)( pMsg->target, pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glTexEnvfv ( __GLcontext *gc, IN GLMSG_TEXENVFV *pMsg )
{
    (*gc->srvDispatchTable.TexEnvfv)( pMsg->target, pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glTexEnviv ( __GLcontext *gc, IN GLMSG_TEXENVIV *pMsg )
{
    (*gc->srvDispatchTable.TexEnviv)( pMsg->target, pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glTexGenfv ( __GLcontext *gc, IN GLMSG_TEXGENFV *pMsg )
{
    (*gc->srvDispatchTable.TexGenfv)( pMsg->coord, pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glInitNames ( __GLcontext *gc, IN GLMSG_INITNAMES *pMsg )
{
    (*gc->srvDispatchTable.InitNames)( );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glLoadName ( __GLcontext *gc, IN GLMSG_LOADNAME *pMsg )
{
    (*gc->srvDispatchTable.LoadName)( pMsg->name );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPassThrough ( __GLcontext *gc, IN GLMSG_PASSTHROUGH *pMsg )
{
    (*gc->srvDispatchTable.PassThrough)( pMsg->token );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPopName ( __GLcontext *gc, IN GLMSG_POPNAME *pMsg )
{
    (*gc->srvDispatchTable.PopName)( );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPushName ( __GLcontext *gc, IN GLMSG_PUSHNAME *pMsg )
{
    (*gc->srvDispatchTable.PushName)( pMsg->name );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glDrawBuffer ( __GLcontext *gc, IN GLMSG_DRAWBUFFER *pMsg )
{
    (*gc->srvDispatchTable.DrawBuffer)( pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glClear ( __GLcontext *gc, IN GLMSG_CLEAR *pMsg )
{
    (*gc->srvDispatchTable.Clear)( pMsg->mask );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glClearAccum ( __GLcontext *gc, IN GLMSG_CLEARACCUM *pMsg )
{
    (*gc->srvDispatchTable.ClearAccum)( pMsg->red, pMsg->green, pMsg->blue, pMsg->alpha );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glClearIndex ( __GLcontext *gc, IN GLMSG_CLEARINDEX *pMsg )
{
    (*gc->srvDispatchTable.ClearIndex)( pMsg->c );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glClearColor ( __GLcontext *gc, IN GLMSG_CLEARCOLOR *pMsg )
{
    (*gc->srvDispatchTable.ClearColor)( pMsg->red, pMsg->green, pMsg->blue, pMsg->alpha );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glClearStencil ( __GLcontext *gc, IN GLMSG_CLEARSTENCIL *pMsg )
{
    (*gc->srvDispatchTable.ClearStencil)( pMsg->s );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glClearDepth ( __GLcontext *gc, IN GLMSG_CLEARDEPTH *pMsg )
{
    (*gc->srvDispatchTable.ClearDepth)( pMsg->depth );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glStencilMask ( __GLcontext *gc, IN GLMSG_STENCILMASK *pMsg )
{
    (*gc->srvDispatchTable.StencilMask)( pMsg->mask );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glColorMask ( __GLcontext *gc, IN GLMSG_COLORMASK *pMsg )
{
    (*gc->srvDispatchTable.ColorMask)( pMsg->red, pMsg->green, pMsg->blue, pMsg->alpha );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glDepthMask ( __GLcontext *gc, IN GLMSG_DEPTHMASK *pMsg )
{
    (*gc->srvDispatchTable.DepthMask)( pMsg->flag );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glIndexMask ( __GLcontext *gc, IN GLMSG_INDEXMASK *pMsg )
{
    (*gc->srvDispatchTable.IndexMask)( pMsg->mask );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glAccum ( __GLcontext *gc, IN GLMSG_ACCUM *pMsg )
{
    (*gc->srvDispatchTable.Accum)( pMsg->op, pMsg->value );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glDisable ( __GLcontext *gc, IN GLMSG_DISABLE *pMsg )
{
    (*gc->srvDispatchTable.Disable)( pMsg->cap );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glEnable ( __GLcontext *gc, IN GLMSG_ENABLE *pMsg )
{
    (*gc->srvDispatchTable.Enable)( pMsg->cap );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPopAttrib ( __GLcontext *gc, IN GLMSG_POPATTRIB *pMsg )
{
    (*gc->srvDispatchTable.PopAttrib)( );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPushAttrib ( __GLcontext *gc, IN GLMSG_PUSHATTRIB *pMsg )
{
    (*gc->srvDispatchTable.PushAttrib)( pMsg->mask );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glMapGrid1f ( __GLcontext *gc, IN GLMSG_MAPGRID1F *pMsg )
{
    (*gc->srvDispatchTable.MapGrid1f)( pMsg->un, pMsg->u1, pMsg->u2 );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glMapGrid2f ( __GLcontext *gc, IN GLMSG_MAPGRID2F *pMsg )
{
    (*gc->srvDispatchTable.MapGrid2f)( pMsg->un, pMsg->u1, pMsg->u2, pMsg->vn, pMsg->v1, pMsg->v2 );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glAlphaFunc ( __GLcontext *gc, IN GLMSG_ALPHAFUNC *pMsg )
{
    (*gc->srvDispatchTable.AlphaFunc)( pMsg->func, pMsg->ref );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glBlendFunc ( __GLcontext *gc, IN GLMSG_BLENDFUNC *pMsg )
{
    (*gc->srvDispatchTable.BlendFunc)( pMsg->sfactor, pMsg->dfactor );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glLogicOp ( __GLcontext *gc, IN GLMSG_LOGICOP *pMsg )
{
    (*gc->srvDispatchTable.LogicOp)( pMsg->opcode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glStencilFunc ( __GLcontext *gc, IN GLMSG_STENCILFUNC *pMsg )
{
    (*gc->srvDispatchTable.StencilFunc)( pMsg->func, pMsg->ref, pMsg->mask );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glStencilOp ( __GLcontext *gc, IN GLMSG_STENCILOP *pMsg )
{
    (*gc->srvDispatchTable.StencilOp)( pMsg->fail, pMsg->zfail, pMsg->zpass );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glDepthFunc ( __GLcontext *gc, IN GLMSG_DEPTHFUNC *pMsg )
{
    (*gc->srvDispatchTable.DepthFunc)( pMsg->func );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPixelZoom ( __GLcontext *gc, IN GLMSG_PIXELZOOM *pMsg )
{
    (*gc->srvDispatchTable.PixelZoom)( pMsg->xfactor, pMsg->yfactor );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPixelTransferf ( __GLcontext *gc, IN GLMSG_PIXELTRANSFERF *pMsg )
{
    (*gc->srvDispatchTable.PixelTransferf)( pMsg->pname, pMsg->param );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPixelTransferi ( __GLcontext *gc, IN GLMSG_PIXELTRANSFERI *pMsg )
{
    (*gc->srvDispatchTable.PixelTransferi)( pMsg->pname, pMsg->param );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPixelStoref ( __GLcontext *gc, IN GLMSG_PIXELSTOREF *pMsg )
{
    (*gc->srvDispatchTable.PixelStoref)( pMsg->pname, pMsg->param );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPixelStorei ( __GLcontext *gc, IN GLMSG_PIXELSTOREI *pMsg )
{
    (*gc->srvDispatchTable.PixelStorei)( pMsg->pname, pMsg->param );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPixelMapfv ( __GLcontext *gc, IN GLMSG_PIXELMAPFV *pMsg )
{

// VARIABLE_IN

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->valuesOff;

    (*gc->srvDispatchTable.PixelMapfv)( pMsg->map, pMsg->mapsize, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glPixelMapuiv ( __GLcontext *gc, IN GLMSG_PIXELMAPUIV *pMsg )
{

// VARIABLE_IN

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->valuesOff;

    (*gc->srvDispatchTable.PixelMapuiv)( pMsg->map, pMsg->mapsize, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glPixelMapusv ( __GLcontext *gc, IN GLMSG_PIXELMAPUSV *pMsg )
{

// VARIABLE_IN

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->valuesOff;

    (*gc->srvDispatchTable.PixelMapusv)( pMsg->map, pMsg->mapsize, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glReadBuffer ( __GLcontext *gc, IN GLMSG_READBUFFER *pMsg )
{
    (*gc->srvDispatchTable.ReadBuffer)( pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glCopyPixels ( __GLcontext *gc, IN GLMSG_COPYPIXELS *pMsg )
{
#ifdef _MCD_
    if (((__GLGENcontext *)gc)->pMcdState)
    {
    // This function potentially touches the framebuffer memory.  Since,
    // this function is not going to first pass through the MCD driver
    // (which would give the MCD driver the oportunity to sync to the HW),
    // we need to do this synchronization explicitly.

        GenMcdSynchronize((__GLGENcontext *)gc);
    }
#endif

    (*gc->srvDispatchTable.CopyPixels)( pMsg->x, pMsg->y, pMsg->width, pMsg->height, pMsg->type );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetBooleanv ( __GLcontext *gc, IN GLMSG_GETBOOLEANV *pMsg )
{
    (*gc->srvDispatchTable.GetBooleanv)( pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetClipPlane ( __GLcontext *gc, IN GLMSG_GETCLIPPLANE *pMsg )
{
    (*gc->srvDispatchTable.GetClipPlane)( pMsg->plane, pMsg->equation );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetDoublev ( __GLcontext *gc, IN GLMSG_GETDOUBLEV *pMsg )
{
    (*gc->srvDispatchTable.GetDoublev)( pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetError ( __GLcontext *gc, IN GLMSG_GETERROR *pMsg )
{
    GLTEB_RETURNVALUE() =
        (ULONG)(*gc->srvDispatchTable.GetError)( );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetFloatv ( __GLcontext *gc, IN GLMSG_GETFLOATV *pMsg )
{
    (*gc->srvDispatchTable.GetFloatv)( pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetIntegerv ( __GLcontext *gc, IN GLMSG_GETINTEGERV *pMsg )
{
    (*gc->srvDispatchTable.GetIntegerv)( pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetLightfv ( __GLcontext *gc, IN GLMSG_GETLIGHTFV *pMsg )
{
    (*gc->srvDispatchTable.GetLightfv)( pMsg->light, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetLightiv ( __GLcontext *gc, IN GLMSG_GETLIGHTIV *pMsg )
{
    (*gc->srvDispatchTable.GetLightiv)( pMsg->light, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetMapdv ( __GLcontext *gc, IN GLMSG_GETMAPDV *pMsg )
{

// VARIABLE_OUT

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->vOff;

    (*gc->srvDispatchTable.GetMapdv)( pMsg->target, pMsg->query, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glGetMapfv ( __GLcontext *gc, IN GLMSG_GETMAPFV *pMsg )
{

// VARIABLE_OUT

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->vOff;

    (*gc->srvDispatchTable.GetMapfv)( pMsg->target, pMsg->query, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glGetMapiv ( __GLcontext *gc, IN GLMSG_GETMAPIV *pMsg )
{

// VARIABLE_OUT

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->vOff;

    (*gc->srvDispatchTable.GetMapiv)( pMsg->target, pMsg->query, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glGetMaterialfv ( __GLcontext *gc, IN GLMSG_GETMATERIALFV *pMsg )
{
    (*gc->srvDispatchTable.GetMaterialfv)( pMsg->face, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetMaterialiv ( __GLcontext *gc, IN GLMSG_GETMATERIALIV *pMsg )
{
    (*gc->srvDispatchTable.GetMaterialiv)( pMsg->face, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetPixelMapfv ( __GLcontext *gc, IN GLMSG_GETPIXELMAPFV *pMsg )
{

// VARIABLE_OUT

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->valuesOff;

    (*gc->srvDispatchTable.GetPixelMapfv)( pMsg->map, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glGetPixelMapuiv ( __GLcontext *gc, IN GLMSG_GETPIXELMAPUIV *pMsg )
{

// VARIABLE_OUT

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->valuesOff;

    (*gc->srvDispatchTable.GetPixelMapuiv)( pMsg->map, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glGetPixelMapusv ( __GLcontext *gc, IN GLMSG_GETPIXELMAPUSV *pMsg )
{

// VARIABLE_OUT

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->valuesOff;

    (*gc->srvDispatchTable.GetPixelMapusv)( pMsg->map, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glGetTexEnvfv ( __GLcontext *gc, IN GLMSG_GETTEXENVFV *pMsg )
{
    (*gc->srvDispatchTable.GetTexEnvfv)( pMsg->target, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetTexEnviv ( __GLcontext *gc, IN GLMSG_GETTEXENVIV *pMsg )
{
    (*gc->srvDispatchTable.GetTexEnviv)( pMsg->target, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetTexGendv ( __GLcontext *gc, IN GLMSG_GETTEXGENDV *pMsg )
{
    (*gc->srvDispatchTable.GetTexGendv)( pMsg->coord, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetTexGenfv ( __GLcontext *gc, IN GLMSG_GETTEXGENFV *pMsg )
{
    (*gc->srvDispatchTable.GetTexGenfv)( pMsg->coord, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetTexGeniv ( __GLcontext *gc, IN GLMSG_GETTEXGENIV *pMsg )
{
    (*gc->srvDispatchTable.GetTexGeniv)( pMsg->coord, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetTexParameterfv ( __GLcontext *gc, IN GLMSG_GETTEXPARAMETERFV *pMsg )
{
    (*gc->srvDispatchTable.GetTexParameterfv)( pMsg->target, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetTexParameteriv ( __GLcontext *gc, IN GLMSG_GETTEXPARAMETERIV *pMsg )
{
    (*gc->srvDispatchTable.GetTexParameteriv)( pMsg->target, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetTexLevelParameterfv ( __GLcontext *gc, IN GLMSG_GETTEXLEVELPARAMETERFV *pMsg )
{
    (*gc->srvDispatchTable.GetTexLevelParameterfv)( pMsg->target, pMsg->level, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetTexLevelParameteriv ( __GLcontext *gc, IN GLMSG_GETTEXLEVELPARAMETERIV *pMsg )
{
    (*gc->srvDispatchTable.GetTexLevelParameteriv)( pMsg->target, pMsg->level, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glIsEnabled ( __GLcontext *gc, IN GLMSG_ISENABLED *pMsg )
{
    GLTEB_RETURNVALUE() =
        (ULONG)(*gc->srvDispatchTable.IsEnabled)( pMsg->cap );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glDepthRange ( __GLcontext *gc, IN GLMSG_DEPTHRANGE *pMsg )
{
    (*gc->srvDispatchTable.DepthRange)( pMsg->zNear, pMsg->zFar );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glFrustum ( __GLcontext *gc, IN GLMSG_FRUSTUM *pMsg )
{
    (*gc->srvDispatchTable.Frustum)( pMsg->left, pMsg->right, pMsg->bottom, pMsg->top, pMsg->zNear, pMsg->zFar );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glLoadIdentity ( __GLcontext *gc, IN GLMSG_LOADIDENTITY *pMsg )
{
    (*gc->srvDispatchTable.LoadIdentity)( );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glLoadMatrixf ( __GLcontext *gc, IN GLMSG_LOADMATRIXF *pMsg )
{
    (*gc->srvDispatchTable.LoadMatrixf)( pMsg->m );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glMatrixMode ( __GLcontext *gc, IN GLMSG_MATRIXMODE *pMsg )
{
    (*gc->srvDispatchTable.MatrixMode)( pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glMultMatrixf ( __GLcontext *gc, IN GLMSG_MULTMATRIXF *pMsg )
{
    (*gc->srvDispatchTable.MultMatrixf)( pMsg->m );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glOrtho ( __GLcontext *gc, IN GLMSG_ORTHO *pMsg )
{
    (*gc->srvDispatchTable.Ortho)( pMsg->left, pMsg->right, pMsg->bottom, pMsg->top, pMsg->zNear, pMsg->zFar );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPopMatrix ( __GLcontext *gc, IN GLMSG_POPMATRIX *pMsg )
{
    (*gc->srvDispatchTable.PopMatrix)( );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPushMatrix ( __GLcontext *gc, IN GLMSG_PUSHMATRIX *pMsg )
{
    (*gc->srvDispatchTable.PushMatrix)( );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glRotatef ( __GLcontext *gc, IN GLMSG_ROTATEF *pMsg )
{
    (*gc->srvDispatchTable.Rotatef)( pMsg->angle, pMsg->x, pMsg->y, pMsg->z );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glScalef ( __GLcontext *gc, IN GLMSG_SCALEF *pMsg )
{
    (*gc->srvDispatchTable.Scalef)( pMsg->x, pMsg->y, pMsg->z );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glTranslatef ( __GLcontext *gc, IN GLMSG_TRANSLATEF *pMsg )
{
    (*gc->srvDispatchTable.Translatef)( pMsg->x, pMsg->y, pMsg->z );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glViewport ( __GLcontext *gc, IN GLMSG_VIEWPORT *pMsg )
{
    (*gc->srvDispatchTable.Viewport)( pMsg->x, pMsg->y, pMsg->width, pMsg->height );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}
